const t='{"documentCount":87,"nextId":87,"documentIds":{"0":"/vitepressBlog/algorithm/#这是我日常学习算法时候做的笔记","1":"/vitepressBlog/algorithm/leetcode/011.盛水最多的容器.html#_11-盛水最多的容器","2":"/vitepressBlog/algorithm/leetcode/011.盛水最多的容器.html#算法思路","3":"/vitepressBlog/algorithm/leetcode/011.盛水最多的容器.html#复杂度分析","4":"/vitepressBlog/algorithm/leetcode/019.删除链表的倒数第N个节点.html#_019-删除链表的倒数第n个节点","5":"/vitepressBlog/algorithm/leetcode/019.删除链表的倒数第N个节点.html#算法思路","6":"/vitepressBlog/algorithm/leetcode/019.删除链表的倒数第N个节点.html#方法一-计算链表的长度","7":"/vitepressBlog/algorithm/leetcode/019.删除链表的倒数第N个节点.html#复杂度分析","8":"/vitepressBlog/algorithm/leetcode/019.删除链表的倒数第N个节点.html#方法二-使用栈","9":"/vitepressBlog/algorithm/leetcode/019.删除链表的倒数第N个节点.html#复杂度分析-1","10":"/vitepressBlog/algorithm/leetcode/019.删除链表的倒数第N个节点.html#方法三-使用快慢指针","11":"/vitepressBlog/algorithm/leetcode/019.删除链表的倒数第N个节点.html#复杂度分析-2","12":"/vitepressBlog/algorithm/leetcode/020.有效括号.html#_20-有效的括号","13":"/vitepressBlog/algorithm/leetcode/020.有效括号.html#算法思路","14":"/vitepressBlog/algorithm/leetcode/020.有效括号.html#复杂度分析","15":"/vitepressBlog/algorithm/leetcode/021.合并两个有序链表.html#_21-合并两个有序链表","16":"/vitepressBlog/algorithm/leetcode/021.合并两个有序链表.html#算法思路","17":"/vitepressBlog/algorithm/leetcode/021.合并两个有序链表.html#方法一-迭代法","18":"/vitepressBlog/algorithm/leetcode/021.合并两个有序链表.html#复杂度分析","19":"/vitepressBlog/algorithm/leetcode/026.删除有序数组中的重复项.html#_026-删除有序数组中的重复项","20":"/vitepressBlog/algorithm/leetcode/026.删除有序数组中的重复项.html#算法思路","21":"/vitepressBlog/algorithm/leetcode/026.删除有序数组中的重复项.html#复杂度分析","22":"/vitepressBlog/algorithm/leetcode/046.全排列.html#_46-全排列","23":"/vitepressBlog/algorithm/leetcode/046.全排列.html#算法思路","24":"/vitepressBlog/algorithm/leetcode/053.最大子数组和.html#_053-最大子数组和","25":"/vitepressBlog/algorithm/leetcode/053.最大子数组和.html#算法思路","26":"/vitepressBlog/algorithm/leetcode/053.最大子数组和.html#复杂度分析","27":"/vitepressBlog/algorithm/leetcode/053.最大子数组和.html#复习","28":"/vitepressBlog/algorithm/leetcode/056.合并区间.html#_056-合并区间","29":"/vitepressBlog/algorithm/leetcode/056.合并区间.html#算法思路","30":"/vitepressBlog/algorithm/leetcode/056.合并区间.html#复杂度分析","31":"/vitepressBlog/algorithm/leetcode/07.整数反转.html#_07-整数反转","32":"/vitepressBlog/algorithm/leetcode/07.整数反转.html#算法思路","33":"/vitepressBlog/algorithm/leetcode/07.整数反转.html#复杂度分析","34":"/vitepressBlog/algorithm/leetcode/070.爬楼梯.html#_70-爬楼梯","35":"/vitepressBlog/algorithm/leetcode/070.爬楼梯.html#算法思路","36":"/vitepressBlog/algorithm/leetcode/1.两数之和.html#_1-两数之和","37":"/vitepressBlog/algorithm/leetcode/1.两数之和.html#算法思路","38":"/vitepressBlog/algorithm/leetcode/1.两数之和.html#方法一-暴力枚举","39":"/vitepressBlog/algorithm/leetcode/1.两数之和.html#方法二-借助哈希表","40":"/vitepressBlog/algorithm/leetcode/1.两数之和.html#方法三-基于哈希表只遍历一次","41":"/vitepressBlog/algorithm/leetcode/1.两数之和.html#复杂度分析","42":"/vitepressBlog/algorithm/leetcode/1.两数之和.html#易错点","43":"/vitepressBlog/algorithm/leetcode/121.买卖股票的最佳时机.html#_121-买卖股票的最佳时机","44":"/vitepressBlog/algorithm/leetcode/121.买卖股票的最佳时机.html#算法思路","45":"/vitepressBlog/algorithm/leetcode/121.买卖股票的最佳时机.html#方法一-暴力法","46":"/vitepressBlog/algorithm/leetcode/121.买卖股票的最佳时机.html#方法二-一次遍历","47":"/vitepressBlog/algorithm/leetcode/121.买卖股票的最佳时机.html#复杂度分析","48":"/vitepressBlog/algorithm/leetcode/146.LRU缓存.html#_146-lru-缓存","49":"/vitepressBlog/algorithm/leetcode/146.LRU缓存.html#算法思路","50":"/vitepressBlog/algorithm/leetcode/146.LRU缓存.html#复杂度分析","51":"/vitepressBlog/algorithm/leetcode/2.两数相加.html#_02-两数相加","52":"/vitepressBlog/algorithm/leetcode/2.两数相加.html#算法思路","53":"/vitepressBlog/algorithm/leetcode/2.两数相加.html#复杂度分析","54":"/vitepressBlog/algorithm/leetcode/206.反转链表.html#_206-反转链表","55":"/vitepressBlog/algorithm/leetcode/206.反转链表.html#算法思路","56":"/vitepressBlog/algorithm/leetcode/206.反转链表.html#方法一-迭代","57":"/vitepressBlog/algorithm/leetcode/206.反转链表.html#方法二-递归","58":"/vitepressBlog/algorithm/leetcode/206.反转链表.html#复杂度分析","59":"/vitepressBlog/algorithm/leetcode/3.无重复字符的最长子串.html#_3-无重复字符的最长子串","60":"/vitepressBlog/algorithm/leetcode/3.无重复字符的最长子串.html#算法思路","61":"/vitepressBlog/algorithm/leetcode/3.无重复字符的最长子串.html#使用set数据结构配合滑动窗口能够提高效率","62":"/vitepressBlog/algorithm/leetcode/3.无重复字符的最长子串.html#复杂度分析","63":"/vitepressBlog/algorithm/leetcode/4.寻找两个正序数组的中位数.html#_4-寻找两个正序数组的中位数","64":"/vitepressBlog/algorithm/leetcode/4.寻找两个正序数组的中位数.html#算法思路","65":"/vitepressBlog/algorithm/leetcode/5.最长回文子串.html#_5-最长回文子串","66":"/vitepressBlog/algorithm/leetcode/5.最长回文子串.html#算法思路","67":"/vitepressBlog/algorithm/leetcode/5.最长回文子串.html#复杂度分析","68":"/vitepressBlog/algorithm/niuke/NC298.删除链表的节点.html#nc298-删除链表的节点","69":"/vitepressBlog/algorithm/niuke/NC298.删除链表的节点.html#算法思路","70":"/vitepressBlog/algorithm/niuke/NC37.合并区间.html#nc37-合并区间","71":"/vitepressBlog/algorithm/niuke/NC37.合并区间.html#算法思路","72":"/vitepressBlog/algorithm/niuke/NC37.合并区间.html#复杂度分析","73":"/vitepressBlog/algorithm/niuke/NC41.最长无重复子数组.html#nc41-最长无重复子数组","74":"/vitepressBlog/algorithm/niuke/NC41.最长无重复子数组.html#算法思路","75":"/vitepressBlog/algorithm/niuke/NC41.最长无重复子数组.html#复杂度分析","76":"/vitepressBlog/algorithm/niuke/NC57.反转数字.html#nc57-反转数字","77":"/vitepressBlog/algorithm/niuke/NC57.反转数字.html#算法思路","78":"/vitepressBlog/algorithm/niuke/NC57.反转数字.html#复杂度分析","79":"/vitepressBlog/algorithm/niuke/NC78.反转链表.html#nc78-反转链表","80":"/vitepressBlog/algorithm/niuke/NC78.反转链表.html#算法思路","81":"/vitepressBlog/algorithm/niuke/NC78.反转链表.html#方法一-迭代","82":"/vitepressBlog/algorithm/niuke/NC78.反转链表.html#方法二-递归","83":"/vitepressBlog/algorithm/niuke/NC78.反转链表.html#复杂度分析","84":"/vitepressBlog/react/#react进阶学习","85":"/vitepressBlog/react/react-advance/认识jsx.html#认识jsx","86":"/vitepressBlog/react/react-advance/认识jsx.html#一-我们写的-jsx-终将变成什么"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[1,1,1],"1":[2,1,1],"2":[1,2,74],"3":[1,2,8],"4":[2,1,1],"5":[1,2,22],"6":[3,3,79],"7":[2,3,7],"8":[2,3,81],"9":[1,3,7],"10":[2,3,57],"11":[1,2,7],"12":[2,1,1],"13":[1,2,122],"14":[1,2,17],"15":[2,1,1],"16":[1,2,1],"17":[3,3,98],"18":[1,2,22],"19":[2,1,1],"20":[2,2,97],"21":[1,2,23],"22":[2,1,1],"23":[1,2,127],"24":[2,1,1],"25":[1,2,76],"26":[1,2,11],"27":[1,2,7],"28":[2,1,1],"29":[1,2,63],"30":[1,2,17],"31":[2,1,1],"32":[2,2,53],"33":[1,2,28],"34":[2,1,1],"35":[1,2,101],"36":[2,1,1],"37":[1,2,1],"38":[2,3,45],"39":[2,3,88],"40":[2,3,29],"41":[1,2,13],"42":[1,2,11],"43":[2,1,1],"44":[1,2,19],"45":[2,3,44],"46":[2,3,71],"47":[1,2,18],"48":[3,1,1],"49":[1,3,110],"50":[1,3,64],"51":[2,1,24],"52":[1,2,110],"53":[1,2,15],"54":[2,1,1],"55":[1,2,1],"56":[2,3,65],"57":[2,3,52],"58":[1,2,20],"59":[2,1,1],"60":[1,2,83],"61":[1,2,38],"62":[1,2,38],"63":[2,1,31],"64":[1,2,116],"65":[2,1,1],"66":[1,2,117],"67":[1,2,69],"68":[2,1,1],"69":[1,2,70],"70":[2,1,1],"71":[1,2,70],"72":[1,2,17],"73":[2,1,1],"74":[1,2,165],"75":[1,2,32],"76":[2,1,1],"77":[1,2,54],"78":[1,2,28],"79":[2,1,1],"80":[1,2,1],"81":[2,3,65],"82":[2,3,52],"83":[1,2,20],"84":[1,1,1],"85":[1,1,1],"86":[4,1,93]},"averageFieldLength":[1.5172413793103448,1.8850574712643677,36.64367816091954],"storedFields":{"0":{"title":"这是我日常学习算法时候做的笔记","titles":[]},"1":{"title":"11.盛水最多的容器","titles":[]},"2":{"title":"算法思路","titles":["11.盛水最多的容器"]},"3":{"title":"复杂度分析","titles":["11.盛水最多的容器"]},"4":{"title":"019.删除链表的倒数第N个节点","titles":[]},"5":{"title":"算法思路","titles":["019.删除链表的倒数第N个节点"]},"6":{"title":"方法一：计算链表的长度：","titles":["019.删除链表的倒数第N个节点","算法思路"]},"7":{"title":"复杂度分析：","titles":["019.删除链表的倒数第N个节点","算法思路"]},"8":{"title":"方法二：使用栈","titles":["019.删除链表的倒数第N个节点","算法思路"]},"9":{"title":"复杂度分析","titles":["019.删除链表的倒数第N个节点","算法思路"]},"10":{"title":"方法三：使用快慢指针","titles":["019.删除链表的倒数第N个节点","算法思路"]},"11":{"title":"复杂度分析","titles":["019.删除链表的倒数第N个节点"]},"12":{"title":"20.有效的括号","titles":[]},"13":{"title":"算法思路","titles":["20.有效的括号"]},"14":{"title":"复杂度分析","titles":["20.有效的括号"]},"15":{"title":"21.合并两个有序链表","titles":[]},"16":{"title":"算法思路","titles":["21.合并两个有序链表"]},"17":{"title":"方法一：迭代法：","titles":["21.合并两个有序链表","算法思路"]},"18":{"title":"复杂度分析","titles":["21.合并两个有序链表"]},"19":{"title":"026.删除有序数组中的重复项","titles":[]},"20":{"title":"算法思路：","titles":["026.删除有序数组中的重复项"]},"21":{"title":"复杂度分析","titles":["026.删除有序数组中的重复项"]},"22":{"title":"46.全排列","titles":[]},"23":{"title":"算法思路","titles":["46.全排列"]},"24":{"title":"053.最大子数组和","titles":[]},"25":{"title":"算法思路","titles":["053.最大子数组和"]},"26":{"title":"复杂度分析","titles":["053.最大子数组和"]},"27":{"title":"复习","titles":["053.最大子数组和"]},"28":{"title":"056.合并区间","titles":[]},"29":{"title":"算法思路","titles":["056.合并区间"]},"30":{"title":"复杂度分析","titles":["056.合并区间"]},"31":{"title":"07.整数反转","titles":[]},"32":{"title":"算法思路：","titles":["07.整数反转"]},"33":{"title":"复杂度分析","titles":["07.整数反转"]},"34":{"title":"70.爬楼梯","titles":[]},"35":{"title":"算法思路","titles":["70.爬楼梯"]},"36":{"title":"1.两数之和","titles":[]},"37":{"title":"算法思路","titles":["1.两数之和"]},"38":{"title":"方法一：暴力枚举","titles":["1.两数之和","算法思路"]},"39":{"title":"方法二：借助哈希表","titles":["1.两数之和","算法思路"]},"40":{"title":"方法三：基于哈希表只遍历一次","titles":["1.两数之和","算法思路"]},"41":{"title":"复杂度分析","titles":["1.两数之和"]},"42":{"title":"易错点","titles":["1.两数之和"]},"43":{"title":"121.买卖股票的最佳时机","titles":[]},"44":{"title":"算法思路","titles":["121.买卖股票的最佳时机"]},"45":{"title":"方法一：暴力法","titles":["121.买卖股票的最佳时机","算法思路"]},"46":{"title":"方法二：一次遍历","titles":["121.买卖股票的最佳时机","算法思路"]},"47":{"title":"复杂度分析","titles":["121.买卖股票的最佳时机"]},"48":{"title":"146.LRU 缓存","titles":[]},"49":{"title":"算法思路","titles":["146.LRU 缓存"]},"50":{"title":"复杂度分析","titles":["146.LRU 缓存"]},"51":{"title":"02.两数相加","titles":[]},"52":{"title":"算法思路","titles":["02.两数相加"]},"53":{"title":"复杂度分析","titles":["02.两数相加"]},"54":{"title":"206.反转链表","titles":[]},"55":{"title":"算法思路","titles":["206.反转链表"]},"56":{"title":"方法一：迭代","titles":["206.反转链表","算法思路"]},"57":{"title":"方法二：递归","titles":["206.反转链表","算法思路"]},"58":{"title":"复杂度分析","titles":["206.反转链表"]},"59":{"title":"3.无重复字符的最长子串","titles":[]},"60":{"title":"算法思路","titles":["3.无重复字符的最长子串"]},"61":{"title":"使用set数据结构配合滑动窗口能够提高效率","titles":["3.无重复字符的最长子串"]},"62":{"title":"复杂度分析","titles":["3.无重复字符的最长子串"]},"63":{"title":"4.寻找两个正序数组的中位数","titles":[]},"64":{"title":"算法思路","titles":["4.寻找两个正序数组的中位数"]},"65":{"title":"5.最长回文子串","titles":[]},"66":{"title":"算法思路","titles":["5.最长回文子串"]},"67":{"title":"复杂度分析","titles":["5.最长回文子串"]},"68":{"title":"NC298.删除链表的节点","titles":[]},"69":{"title":"算法思路","titles":["NC298.删除链表的节点"]},"70":{"title":"NC37.合并区间","titles":[]},"71":{"title":"算法思路","titles":["NC37.合并区间"]},"72":{"title":"复杂度分析","titles":["NC37.合并区间"]},"73":{"title":"NC41.最长无重复子数组","titles":[]},"74":{"title":"算法思路","titles":["NC41.最长无重复子数组"]},"75":{"title":"复杂度分析","titles":["NC41.最长无重复子数组"]},"76":{"title":"NC57.反转数字","titles":[]},"77":{"title":"算法思路","titles":["NC57.反转数字"]},"78":{"title":"复杂度分析","titles":["NC57.反转数字"]},"79":{"title":"NC78.反转链表","titles":[]},"80":{"title":"算法思路","titles":["NC78.反转链表"]},"81":{"title":"方法一：迭代","titles":["NC78.反转链表","算法思路"]},"82":{"title":"方法二：递归","titles":["NC78.反转链表","算法思路"]},"83":{"title":"复杂度分析","titles":["NC78.反转链表"]},"84":{"title":"React进阶学习","titles":[]},"85":{"title":"认识jsx","titles":[]},"86":{"title":"一 我们写的 JSX 终将变成什么","titles":["认识jsx"]}},"dirtCount":0,"index":[["三元运算",{"2":{"86":1}}],["组件类型",{"2":{"86":1}}],["文本类型",{"2":{"86":1}}],["👽👽",{"2":{"86":1}}],["状态",{"2":{"86":1}}],["我写了一段",{"2":{"86":1}}],["我们一步步看看它最后会变成什么样子",{"2":{"86":1}}],["我们写的",{"0":{"86":1}}],["我们首先计算了两个数组的长度和中位数的下标",{"2":{"64":1}}],["我们首先从头节点开始对链表进行一次遍历",{"2":{"6":1}}],["我们要移动这个队列",{"2":{"60":1,"74":1}}],["我们要遍历两个链表的全部位置",{"2":{"53":1}}],["我们发现了重复的字符a",{"2":{"60":1,"74":1}}],["我们想要把它改成",{"2":{"56":1,"81":1}}],["我们想要实现一个o",{"2":{"38":1}}],["我们建立一个",{"2":{"52":1}}],["我们存储的数据是",{"2":{"49":1}}],["我们都可以选择是否出售股票",{"2":{"46":1}}],["我们都需要把",{"2":{"17":1}}],["我们来假设自己购买股票",{"2":{"46":1}}],["我们会得到",{"2":{"46":1}}],["我们会期望在后续的遍历中",{"2":{"13":1}}],["我们站在上帝视角回看之前日期的股票价格",{"2":{"45":1}}],["我们的规则是",{"2":{"42":1}}],["我们用f",{"2":{"35":1}}],["我们只需要把队列的左边的元素移除出去就可以了",{"2":{"60":1,"74":1}}],["我们只需要存储",{"2":{"47":1}}],["我们只需要遍历价格数组一遍",{"2":{"46":1}}],["我们只需要一次线性扫描",{"2":{"30":1,"72":1}}],["我们只需要常数的空间存放若干变量",{"2":{"18":1}}],["我们将列表中的区间按照左端点升序排列",{"2":{"29":1,"71":1}}],["我们按照区间的左端点进行排序",{"2":{"29":1,"71":1}}],["我们对",{"2":{"17":1}}],["我们就可以写如下代码了",{"2":{"57":1,"82":1}}],["我们就可以假设自己的股票就是那天购买的",{"2":{"46":1}}],["我们就得到了最好的答案",{"2":{"46":1}}],["我们就需要对这两项的贡献求和",{"2":{"35":1}}],["我们就把",{"2":{"17":1}}],["我们就不需要对头节点进行特殊的判断了",{"2":{"5":1}}],["我们重复以下过程",{"2":{"17":1}}],["我们维护一个cur指针",{"2":{"17":1}}],["我们设定一个虚拟节点",{"2":{"17":1}}],["我们可以优化一下",{"2":{"74":1}}],["我们可以封装成一个类",{"2":{"49":1}}],["我们可以将方法挂载到构造函数上面",{"2":{"49":1}}],["我们可以",{"2":{"39":1,"41":1}}],["我们可以准备一个记忆数组",{"2":{"35":1}}],["我们可以用一颗树来表示上面代码的执行过程",{"2":{"35":1}}],["我们可以从3级台阶向上爬一级",{"2":{"35":1}}],["我们可以从哑节点开始遍历l",{"2":{"6":1}}],["我们可以看到",{"2":{"35":1}}],["我们可以直接将这个区间加入数组merged的末尾",{"2":{"29":1,"71":1}}],["我们可以直接返回",{"2":{"13":1}}],["我们可以先使用排序的方式将这个二维数组内部的子数组是有顺序的",{"2":{"29":1,"71":1}}],["我们可以使用哈希表来优化这个算法",{"2":{"74":1}}],["我们可以使用哈希表存储每一种括号",{"2":{"13":1}}],["我们可以使用迭代的方法实现上述算法",{"2":{"17":1}}],["我们可以取出栈顶的左括号并判断它们是否是相同类型的括号",{"2":{"13":1}}],["我们需要找出",{"2":{"44":1}}],["我们需要找出给定数组中两个数字之间的最大差值即最大利润",{"2":{"44":1}}],["我们需要用当前区间的右端点更新数组merged中最后一个区间的右端点",{"2":{"29":1,"71":1}}],["我们需要做的就是调整它的next指针",{"2":{"17":1}}],["我们需要将一个相同类型的左括号闭合",{"2":{"13":1}}],["我们需要知道节点y的前驱节点x",{"2":{"5":1}}],["我们遍历给定的字符串s",{"2":{"13":1}}],["我们使用了栈来存储节点的引用",{"2":{"8":1}}],["我们弹出栈的第n个节点就是需要删除的节点",{"2":{"8":1}}],["我们也可以在遍历链表的同时将所有节点依次入栈",{"2":{"8":1}}],["我们移动数字较小的那个指针",{"2":{"2":1}}],["我们移动数字较大的那个指针是不合理的",{"2":{"2":1}}],["插槽组件",{"2":{"86":1}}],["渲染",{"2":{"86":1}}],["控制",{"2":{"86":1}}],["理解",{"2":{"86":1}}],["理论上股票价格不会达到这个值",{"2":{"46":1}}],["理论上",{"2":{"45":1}}],["类型",{"2":{"86":2}}],["了解常用的元素会被",{"2":{"86":1}}],["弄清楚jsx",{"2":{"86":1}}],["想要深入学习react",{"2":{"86":1}}],["万物始于jsx",{"2":{"86":1}}],["终将变成什么",{"0":{"86":1}}],["认识jsx",{"0":{"85":1},"1":{"86":1}}],["综合起来",{"2":{"75":1}}],["综上所述",{"2":{"8":1,"33":3,"74":1,"78":3}}],["操作的时间复杂度为",{"2":{"75":1}}],["操作来维护滑动窗口",{"2":{"62":1}}],["效率得到了显著提升",{"2":{"74":1}}],["降低到了",{"2":{"74":1}}],["降低时间复杂度",{"2":{"74":1}}],["相比之前的解法",{"2":{"74":1}}],["优化后的算法时间复杂度为",{"2":{"74":1}}],["优化后的代码如下",{"2":{"74":1}}],["优化后的时间复杂度为",{"2":{"74":1}}],["移除左指针元素",{"2":{"74":2}}],["移动左指针缩小窗口",{"2":{"61":1}}],["移动到next",{"2":{"56":1,"81":1}}],["移动到",{"2":{"56":1,"81":1}}],["移动到下一个结点",{"2":{"52":1}}],["移动",{"2":{"10":1,"20":1}}],["移动哪一个指针呢",{"2":{"2":1}}],["作为哈希表来存储窗口中的元素及其索引",{"2":{"74":1}}],["作为哈希表",{"2":{"74":2}}],["作为新链表的尾部",{"2":{"56":1,"81":1}}],["虽然这个解法可以解决问题",{"2":{"74":1}}],["请勿修改",{"2":{"74":2}}],["请你找出并返回这两个正序数组的",{"2":{"63":1}}],["请你将两个数相加",{"2":{"51":1}}],["参数名已经指定",{"2":{"74":2}}],["参考资料",{"2":{"50":1,"67":1}}],["如何移动呢",{"2":{"74":1}}],["如果需要删除的节点是头节点",{"2":{"69":1}}],["如果长度是奇数",{"2":{"64":1}}],["如果数组的总长度是偶数",{"2":{"64":1}}],["如果数组",{"2":{"64":1}}],["如果还没有找到",{"2":{"64":1}}],["如果已经找到了中位数",{"2":{"64":1}}],["如果已经使用过",{"2":{"23":1}}],["如果字符已经在",{"2":{"61":1}}],["如果字符串的长度是奇数",{"2":{"13":2}}],["如果出现过",{"2":{"60":1}}],["如果最后两个数相加完毕之后还有可能有进制",{"2":{"52":1}}],["如果缓存容量已满",{"2":{"50":1}}],["如果存在",{"2":{"50":1}}],["如果键不存在",{"2":{"50":1}}],["如果键存在",{"2":{"50":1}}],["如果size超出了给定的容量范围",{"2":{"49":1}}],["如果sum",{"2":{"25":2,"52":1}}],["如果用ts实现",{"2":{"49":1}}],["如果使用js实现",{"2":{"49":1}}],["如果和当前位置的差值大于最大的利润",{"2":{"46":1}}],["如果当前元素已经在窗口中",{"2":{"74":1}}],["如果当前元素",{"2":{"74":1}}],["如果当前元素在窗口中",{"2":{"74":2}}],["如果当前元素不在窗口中",{"2":{"74":2}}],["如果当前遍历到的元素小于最小值",{"2":{"46":1}}],["如果当前区间的右端点",{"2":{"29":1,"71":1}}],["如果当前区间的左端点",{"2":{"29":1,"71":1}}],["如果当前区间的左端点在数组merged中最后一个区间的右端点之后",{"2":{"29":1,"71":1}}],["如果我是在历史最低点买进的",{"2":{"46":1}}],["如果我是在历史最低点买的股票就好了",{"2":{"46":1}}],["如果我们要删除节点y",{"2":{"5":1}}],["如果我们移动数字较大的指针",{"2":{"2":1}}],["如果在图表上绘制出来",{"2":{"46":1}}],["如果x是小于0的数",{"2":{"32":1,"77":1}}],["如果x是大于0的数",{"2":{"32":1,"77":1}}],["如果传递进来的数组长度为0",{"2":{"29":1,"71":1}}],["如果不相等",{"2":{"20":1}}],["如果不是相同的类型",{"2":{"13":1}}],["如果相等",{"2":{"20":1}}],["如果是",{"2":{"13":1}}],["如果栈为空",{"2":{"13":2}}],["如果栈为空或栈顶元素不是与当前右括号匹配的左括号",{"2":{"13":1}}],["如果栈中没有左括号",{"2":{"13":1}}],["如果",{"2":{"8":2,"13":2,"17":1,"69":2}}],["保存当前节点的索引",{"2":{"69":1}}],["特例处理",{"2":{"69":1}}],["设节点",{"2":{"69":1}}],["设置了一个变量",{"2":{"64":1}}],["设置两个变量",{"2":{"25":1}}],["设置为",{"2":{"8":1}}],["修改引用",{"2":{"69":2}}],["定位节点",{"2":{"69":3}}],["定义一个全排列函数",{"2":{"23":1}}],["提供的代码以",{"2":{"67":1}}],["提交并不会通过",{"2":{"45":1}}],["且两者都具有",{"2":{"67":1}}],["且对应的索引不能是当前的这个索引",{"2":{"39":1}}],["该循环会迭代整个字符串长度",{"2":{"67":1}}],["该循环会一直迭代直到左右两侧字符不相等",{"2":{"67":1}}],["该算法的空间复杂度主要取决于维护的滑动窗口数组",{"2":{"62":1}}],["该算法的空间复杂度是",{"2":{"21":1}}],["该算法使用了滑动窗口的思想",{"2":{"62":1}}],["被调用两次",{"2":{"67":1}}],["稍微解释下上面的helper函数",{"2":{"66":1}}],["剩下",{"2":{"66":1}}],["去掉",{"2":{"66":1}}],["9",{"2":{"66":3}}],["恰好满足",{"2":{"66":1}}],["跳出循环的时候",{"2":{"66":1}}],["逐个比对",{"2":{"66":1}}],["右边界向右",{"2":{"66":1}}],["右括号",{"2":{"13":1}}],["回文串的长度是",{"2":{"66":1}}],["回文串的长度是偶数",{"2":{"66":1}}],["回文串的长度是奇数",{"2":{"66":1}}],["回文中心是两个字符",{"2":{"66":1}}],["回文中心是一个字符",{"2":{"66":1}}],["字符串本身",{"2":{"66":1}}],["字符串转换和反转操作的时间复杂度都是",{"2":{"33":1,"78":1}}],["接下来",{"2":{"86":1}}],["接收三个参数",{"2":{"66":1}}],["接着要做的就是反转节点1",{"2":{"57":1,"82":1}}],["判判断是否是回文串的辅助函数",{"2":{"66":1}}],["判断滑动窗口中是否包含当前这个数组元素",{"2":{"74":1}}],["判断滑动窗口中是否包含当前的这个数组元素",{"2":{"74":1}}],["判断总的长度是否为偶数",{"2":{"64":1}}],["判断加和是不是偶数",{"2":{"64":1}}],["判断是否在数组中出现过",{"2":{"60":1}}],["判断是否已经使用过",{"2":{"23":1}}],["判断字符串是否在滑动窗口数组里面",{"2":{"60":1,"74":1}}],["判断容量",{"2":{"49":1}}],["判断map中是否存在目标值",{"2":{"40":1}}],["判断查找的数字不是第一个数字",{"2":{"39":1}}],["判断",{"2":{"20":1}}],["判断l1和l2哪一个链表的头节点值更小",{"2":{"17":1}}],["判断当前字符是否为右括号",{"2":{"13":1}}],["判断括号的有效性可以使用",{"2":{"13":1}}],["借助函数拿到以奇数和偶数分别为中心的长度",{"2":{"66":1}}],["借助哈希表",{"0":{"39":1}}],["记录最大的长度",{"2":{"66":1}}],["记录历史最低点",{"2":{"46":1}}],["枚举",{"2":{"66":1}}],["添加到合并后的数组中",{"2":{"64":2}}],["添加一个新节点到新链表后面",{"2":{"52":1}}],["小于数组",{"2":{"64":1}}],["依次比较两个指针所指的元素",{"2":{"64":1}}],["依次求每个卖出时机的最大差值",{"2":{"46":1}}],["分别用于检查以",{"2":{"67":1}}],["分别以奇数和偶数的维度来寻找回文子串",{"2":{"66":1}}],["分别指向的是两个数组的开头",{"2":{"64":1}}],["分别指向两个数组的开头",{"2":{"64":1}}],["分别为两个链表的长度",{"2":{"18":1,"53":1}}],["k表示中位数的索引位置",{"2":{"64":1}}],["k",{"2":{"64":3}}],["key=",{"2":{"86":1}}],["keys",{"2":{"49":2,"50":1}}],["key",{"2":{"23":2,"49":23}}],["计算长度的加和",{"2":{"64":1}}],["计算两个数的长度和",{"2":{"64":1}}],["计算链表的长度",{"0":{"6":1},"2":{"6":1}}],["解释",{"2":{"63":2}}],["解题思路就是建立一个新链表",{"2":{"52":1}}],["输出",{"2":{"63":2}}],["输入",{"2":{"63":2}}],["示例",{"2":{"63":2}}],["寻找两个正序数组的中位数",{"0":{"63":1},"1":{"64":1}}],["寻找数组中是否存在target",{"2":{"38":1}}],["查找和删除元素的时间复杂度都是",{"2":{"74":1}}],["查找字符是否在数组中出现过",{"2":{"62":1}}],["查找操作的时间复杂度为",{"2":{"50":1}}],["扩大窗口",{"2":{"61":1}}],["存储滑动窗口内的字符",{"2":{"61":1}}],["存入数组中",{"2":{"35":1}}],["存入了一个二维数组",{"2":{"13":2}}],["求出解",{"2":{"60":1,"74":1}}],["队列变成了abca",{"2":{"60":1,"74":1}}],["满足题目要求",{"2":{"60":1,"74":1}}],["窗口",{"2":{"60":1,"74":1}}],["什么是滑动窗口",{"2":{"60":1,"74":1}}],["滑动窗口右指针",{"2":{"74":2}}],["滑动窗口左指针",{"2":{"74":2}}],["滑动窗口数组可能包含所有不重复的字符",{"2":{"62":1}}],["滑动窗口的左指针",{"2":{"61":1}}],["滑动窗口初始化为一个空数组",{"2":{"60":1}}],["滑动窗口",{"2":{"60":1,"74":1}}],["无重复字符的最长子串",{"0":{"59":1},"1":{"60":1,"61":1,"62":1}}],["无论key在哪个位置",{"2":{"49":1}}],["仅使用了常数级别的额外空间",{"2":{"58":1,"83":1}}],["反转数字",{"0":{"76":1},"1":{"77":1,"78":1}}],["反转后的结果就是它自己",{"2":{"57":1,"82":1}}],["反转链表",{"0":{"54":1,"79":1},"1":{"55":1,"56":1,"57":1,"58":1,"80":1,"81":1,"82":1,"83":1}}],["调用递推公式反转当前节点之后的所有节点",{"2":{"57":3,"82":3}}],["到这里",{"2":{"57":2,"82":2}}],["经过递推公式",{"2":{"57":1,"82":1}}],["把拿到的链表进行反转",{"2":{"57":1,"82":1}}],["退出while循环的条件是",{"2":{"56":1,"81":1}}],["退出循环时候肯定有一个为空",{"2":{"17":1}}],["前置节点",{"2":{"56":1,"81":1}}],["动画图示",{"2":{"56":1,"81":1}}],["动态规划算法会记录子问题的解决方案",{"2":{"67":1}}],["动态规划问题的核心是自底想上的解决问题",{"2":{"35":1}}],["动态规划是首先对数组进行遍历",{"2":{"25":1}}],["动态规划",{"2":{"25":1}}],["还是以abcabcbb为例",{"2":{"60":1}}],["还有重要的一步就是递归终止条件",{"2":{"57":1,"82":1}}],["还需要另一个指针来存储下一个节点",{"2":{"56":1,"81":1}}],["还会重走for循环",{"2":{"23":2}}],["∅",{"2":{"56":2,"81":2}}],["迭代",{"0":{"56":1,"81":1}}],["迭代法",{"0":{"17":1}}],["新的链表的下一个节点",{"2":{"52":1}}],["很显然",{"2":{"52":1}}],["很好理解",{"2":{"35":1}}],["连到",{"2":{"52":1}}],["连续代表不是子序列",{"2":{"25":1}}],["连续",{"2":{"25":2}}],["结点本身不能变",{"2":{"52":1}}],["结点之后",{"2":{"52":1}}],["结点",{"2":{"52":1}}],["结果数组放进第一个数组",{"2":{"29":1,"71":1}}],["开始进行变换",{"2":{"57":1,"82":1}}],["开始翻转",{"2":{"56":1,"81":1}}],["开始查找",{"2":{"39":1}}],["开头",{"2":{"51":1}}],["你可以假设除了数字",{"2":{"51":1}}],["逆序",{"2":{"51":1}}],["非空",{"2":{"51":1}}],["非常合适",{"2":{"49":1}}],["给定两个大小分别为",{"2":{"63":1}}],["给定一个已排序的数组",{"2":{"20":1}}],["给你两个",{"2":{"51":1}}],["数字",{"2":{"51":1}}],["数学",{"2":{"51":1}}],["数组节点类型",{"2":{"86":1}}],["数组中已经有了这个字符串",{"2":{"60":1}}],["数组中两个数的和等于目标值的下标",{"2":{"39":1}}],["数组第",{"2":{"35":1}}],["数组反转和拼接数字时并没有使用额外的空间",{"2":{"33":1,"78":1}}],["数组反转操作的时间复杂度也是",{"2":{"33":1,"78":1}}],["数组",{"2":{"29":1,"39":1,"63":1,"64":2,"71":1}}],["数组的长度",{"2":{"23":5}}],["数组变为",{"2":{"20":1}}],["数组是有序的",{"2":{"20":1}}],["链表",{"2":{"51":1}}],["链表的题目",{"2":{"17":1}}],["递归反转链表什么时候停止呢",{"2":{"57":1,"82":1}}],["递归调用这一部分完成之后",{"2":{"57":1,"82":1}}],["递归解题首先要明确递推公式的含义",{"2":{"57":1,"82":1}}],["递归",{"0":{"57":1,"82":1},"2":{"51":1}}],["递归的终止条件是一个排列中的数字已经选择够了",{"2":{"23":1}}],["递归的终止条件是",{"2":{"23":2}}],["标签",{"2":{"51":1}}],["标记为已经使用",{"2":{"23":1}}],["双向链表的插入和删除操作可以在",{"2":{"50":1}}],["双指针总计最多遍历整个数组一次",{"2":{"3":1}}],["以下都是常用的jsx元素节",{"2":{"86":1}}],["以便在找到中位数的时候计算中位数的值",{"2":{"64":1}}],["以便在下一次的迭代中使用",{"2":{"64":1}}],["以及中位数的下标",{"2":{"64":1}}],["以淘汰使用频率最低的键值对",{"2":{"50":1}}],["以更有效地维护",{"2":{"50":1}}],["以维护",{"2":{"50":1}}],["改进建议",{"2":{"50":1,"67":1}}],["哈希表需要存储",{"2":{"50":1}}],["哈希表的键为右括号",{"2":{"13":1}}],["顺序",{"2":{"50":2}}],["world",{"2":{"86":1}}],["webpack",{"2":{"86":1}}],["window",{"2":{"74":10}}],["wiki",{"2":{"50":1}}],["wikipedia",{"2":{"50":1}}],["will",{"2":{"49":1}}],["while循环中",{"2":{"66":1}}],["while循环的条件是两个都不为空",{"2":{"17":1}}],["while",{"2":{"2":3,"6":1,"8":1,"10":1,"17":2,"18":1,"20":1,"52":4,"56":1,"57":1,"61":1,"66":2,"69":1,"74":2,"81":1,"82":1}}],["your",{"2":{"49":1}}],["同时还要加上进位",{"2":{"52":1}}],["同时移动",{"2":{"10":1}}],["同样是先删除key",{"2":{"49":1}}],["vue",{"2":{"86":1}}],["void",{"2":{"49":2}}],["value",{"2":{"25":1,"49":15,"50":1}}],["val===undefined",{"2":{"6":1,"17":2,"52":2,"56":1,"81":1}}],["val",{"2":{"6":4,"17":11,"52":11,"56":3,"69":11,"81":3}}],["var",{"2":{"2":1,"17":1,"23":1,"25":1,"29":1,"32":1,"35":1,"45":1,"49":3,"52":1,"56":1,"57":3,"60":1,"66":1,"69":1,"77":1,"81":1,"82":3}}],["取值的时候分为两种情况",{"2":{"49":1}}],["取出字符串的长度",{"2":{"13":2}}],["事实上",{"2":{"49":1}}],["关键的点在如果key存在map中应该如何处理",{"2":{"49":1}}],["找到中间位置的索引下标",{"2":{"64":1}}],["找到则放进数组",{"2":{"39":1}}],["找到则记录index",{"2":{"39":1}}],["找出队列出现最长的长度时候",{"2":{"60":1,"74":1}}],["找不到key这种情况很好处理",{"2":{"49":1}}],["根据中位数的定义",{"2":{"64":1}}],["根据题目示例",{"2":{"49":1}}],["根据栈先进后出的原则",{"2":{"8":1}}],["缓存",{"0":{"48":1},"1":{"49":1,"50":1}}],["次迭代",{"2":{"47":1}}],["更新最长子序列长度",{"2":{"74":2}}],["更新最大长度",{"2":{"61":1,"66":1}}],["更新最大值",{"2":{"60":1}}],["更新最小值为当前遍历到的元素",{"2":{"46":1}}],["更新下最大值",{"2":{"60":1}}],["更新右端点为最大值",{"2":{"29":1,"71":1}}],["之后这个cur会不断地向后移动",{"2":{"52":1}}],["之后再更新两个结点",{"2":{"52":1}}],["之后cur",{"2":{"17":1}}],["之外",{"2":{"51":1}}],["之间选择最低点买入",{"2":{"46":1}}],["天卖出股票",{"2":{"46":1}}],["天卖出股票得到的利润就是",{"2":{"46":1}}],["真实场景中",{"2":{"46":1}}],["随着时间的推移",{"2":{"46":1}}],["随后我们再从头节点开始对链表进行遍历",{"2":{"6":1}}],["假设n是链表的长度",{"2":{"56":1,"81":1}}],["假设存在链表",{"2":{"56":1,"81":1}}],["假设数组",{"2":{"20":1}}],["假如计划在",{"2":{"46":1}}],["假定给定的数组是",{"2":{"46":1}}],["按照题目要求直接返回",{"2":{"49":1}}],["按照真实的投资逻辑",{"2":{"45":1}}],["按照算法",{"2":{"6":1}}],["内层就以当前为基准遍历到最后",{"2":{"45":1}}],["外层循环遍历整个数组",{"2":{"74":1,"75":1}}],["外层循环到数组的倒数第二个元素",{"2":{"45":1}}],["外层每遍历一个元素",{"2":{"45":1}}],["投资股票的本质就是低买高卖",{"2":{"45":1}}],["暴力法",{"0":{"45":1}}],["暴力枚举",{"0":{"38":1}}],["−prices",{"2":{"44":1}}],["形式上",{"2":{"44":1}}],["买入价格",{"2":{"44":1}}],["买卖股票的最佳时机",{"0":{"43":1},"1":{"44":1,"45":1,"46":1,"47":1}}],["必须大于第一个数字",{"2":{"44":1}}],["卖出价格",{"2":{"44":1}}],["此外",{"2":{"44":1}}],["此时直接将当前这个数组放进结果集",{"2":{"71":1}}],["此时left和right所在的位置刚好为不符合条件的场景",{"2":{"66":1}}],["此时字符串没有重复元素",{"2":{"60":1,"74":1}}],["此时说明",{"2":{"20":1}}],["此时",{"2":{"8":1,"10":1,"13":1,"20":2,"66":1}}],["此时我们就只需要考虑通用的情况即可",{"2":{"5":1}}],["索引",{"2":{"42":1}}],["索引不重复",{"2":{"40":1}}],["元素类型",{"2":{"86":1}}],["元素",{"2":{"42":1}}],["映射规则总是没有想清楚",{"2":{"42":1}}],["易错点",{"0":{"42":1}}],["基于哈希表只遍历一次",{"0":{"40":1}}],["主要用到的思想是",{"2":{"74":1}}],["主要思路是",{"2":{"66":1}}],["主要的循环遍历字符串",{"2":{"62":1}}],["主要是",{"2":{"58":1,"83":1}}],["主要是栈的开销",{"2":{"9":1}}],["主要分为两种情况",{"2":{"49":1}}],["主要为哈希表的开销",{"2":{"39":1,"41":1}}],["地寻找target",{"2":{"41":1}}],["地寻找",{"2":{"39":1}}],["检查",{"2":{"39":1}}],["检查栈是否为空或栈顶元素与当前右括号的映射不匹配",{"2":{"13":1}}],["都需要在数组中查找一次",{"2":{"62":1}}],["都存在的情况下",{"2":{"52":1}}],["都先将其删除",{"2":{"49":1}}],["都将目标值算出来",{"2":{"39":1}}],["都不是空链表时",{"2":{"17":1}}],["循环遍历整个字符串",{"2":{"67":1}}],["循环结束之后",{"2":{"64":1}}],["循环内的操作是常数时间复杂度",{"2":{"58":1,"83":1}}],["循环退出之后",{"2":{"52":1}}],["循环每一个元素的时候",{"2":{"39":1}}],["循环的条件两个链表中只要有一个不为空就行",{"2":{"52":1}}],["循环的条件设置为两个非空的形式",{"2":{"17":1}}],["循环的次数不会超过两个链表的长度之和",{"2":{"18":1}}],["做一个映射",{"2":{"39":1}}],["做同样的操作",{"2":{"17":1}}],["目标值",{"2":{"39":1}}],["建立map映射",{"2":{"39":1}}],["先判断一下",{"2":{"52":1}}],["先检查键是否存在",{"2":{"50":1}}],["先删除",{"2":{"49":1}}],["先在原map中删除key",{"2":{"49":1}}],["先遍历一遍数组",{"2":{"39":1}}],["先爬两级",{"2":{"35":3}}],["先爬一级",{"2":{"35":3}}],["来存储窗口元素",{"2":{"75":1}}],["来存储左括号",{"2":{"14":1}}],["来表示滑动窗口的左右边界",{"2":{"74":1}}],["来表示滑动窗口",{"2":{"62":1}}],["来指向新链表的最后一个结点",{"2":{"52":1}}],["来建立数字和坐标之间的映射关系",{"2":{"39":1}}],["思路以及算法",{"2":{"38":1}}],["台阶的情况",{"2":{"35":1}}],["位",{"2":{"35":1}}],["代替数组来存储窗口元素",{"2":{"74":1}}],["代表链表中不包含值为val的节点",{"2":{"69":1}}],["代表",{"2":{"35":2}}],["代码中的类名",{"2":{"74":2}}],["代码使用常数空间来存储变量",{"2":{"67":1}}],["代码如下",{"2":{"52":1}}],["代码",{"2":{"10":1,"86":1}}],["准备一个记忆化数组",{"2":{"35":1}}],["下面这个条件的核心是找出当前循环中较小的一个赋值给curr",{"2":{"64":1}}],["下面是相应的",{"2":{"10":1}}],["下次再用到这个节点数据的时候直接从数组中取出来就好",{"2":{"35":1}}],["转移过来",{"2":{"35":1}}],["转换成数字之后需要取反",{"2":{"32":1,"77":1}}],["级",{"2":{"35":1}}],["级或",{"2":{"35":1}}],["级台阶的方案数的和",{"2":{"35":1}}],["级台阶的方案数和爬到第",{"2":{"35":1}}],["级台阶的方案数是爬到第",{"2":{"35":1}}],["两数相加",{"0":{"51":1},"1":{"52":1,"53":1}}],["两数之和",{"0":{"36":1},"1":{"37":1,"38":1,"39":1,"40":1,"41":1,"42":1}}],["两个变量",{"2":{"47":1}}],["两个指针的位置对应的元素值是否相等",{"2":{"20":1}}],["两个指针指向的数字中的较小值",{"2":{"2":1}}],["两个指针指向的数字中较小值",{"2":{"2":1}}],["两种方案可选",{"2":{"35":1}}],["换句话说",{"2":{"35":1}}],["考虑最后一步可能跨了一级台阶",{"2":{"35":1}}],["也都往后面移动",{"2":{"52":1}}],["也是需要判断是否存在的",{"2":{"49":1}}],["也就是当窗口向右扩大的时候",{"2":{"60":1,"74":1}}],["也就是将head指向的节点作为其下一个节点的下一个节点",{"2":{"57":1,"82":1}}],["也就是carry值为1",{"2":{"52":1}}],["也就是说递推公式reverselist的含义是",{"2":{"57":1,"82":1}}],["也就是说",{"2":{"39":1}}],["也就是爬一级",{"2":{"35":1}}],["也可能跨了两级台阶",{"2":{"35":1}}],["也可以从2级台阶向上爬2级",{"2":{"35":1}}],["爬到n阶",{"2":{"35":1}}],["爬楼梯问题",{"2":{"35":1}}],["爬楼梯",{"0":{"34":1},"1":{"35":1}}],["再反转回来是最直观的解法",{"2":{"77":1}}],["再添加",{"2":{"49":1}}],["再从中取最大值",{"2":{"46":1}}],["再遍历一遍数组",{"2":{"39":1}}],["再爬一级",{"2":{"35":3}}],["再爬两级",{"2":{"35":3}}],["再次进入递归逻辑之后",{"2":{"23":1}}],["或者一次爬2级",{"2":{"35":1}}],["或者栈中并没有左括号",{"2":{"13":1}}],["第",{"2":{"46":1}}],["第二个数字",{"2":{"44":1}}],["第二次爬1级",{"2":{"35":1}}],["第一次爬1级",{"2":{"35":1}}],["第一轮完成之后",{"2":{"23":1}}],["总结",{"2":{"67":1}}],["总和",{"2":{"52":1}}],["总会幻想着如果能在最低点买入",{"2":{"45":1}}],["总共几个数",{"2":{"66":1}}],["总共3中方法",{"2":{"35":1}}],["总共2种方法",{"2":{"35":1}}],["总共1种方法",{"2":{"35":1}}],["总是向着收益最大的方向进行",{"2":{"25":1}}],["空间",{"2":{"33":1,"78":1}}],["空间复杂度是o",{"2":{"64":1}}],["空间复杂度分析",{"2":{"21":1,"62":1,"74":1}}],["空间复杂度为",{"2":{"11":1,"62":1,"74":3,"75":2}}],["空间复杂度",{"2":{"3":1,"7":1,"9":1,"14":1,"18":1,"26":1,"30":1,"33":1,"38":1,"39":1,"41":1,"47":1,"50":2,"53":1,"56":1,"58":1,"67":2,"72":1,"75":1,"78":1,"81":1,"83":1}}],["整体的时间复杂度是",{"2":{"62":1}}],["整个数组都不包含重复元素",{"2":{"74":1,"75":1}}],["整个数组中唯一元素的数量即为",{"2":{"20":1}}],["整个代码的空间复杂度保持不变",{"2":{"67":1}}],["整个实现步骤为",{"2":{"39":1}}],["整个函数的空间复杂度是",{"2":{"33":1,"78":1}}],["整个函数的时间复杂度是",{"2":{"33":1,"78":1}}],["整数反转",{"0":{"31":1},"1":{"32":1,"33":1}}],["除了参数和循环内部的临时变量外",{"2":{"67":1}}],["除了滑动窗口数组之外",{"2":{"62":1}}],["除了常量级的辅助变量之外",{"2":{"26":1}}],["除去排序的开销",{"2":{"30":1,"72":1}}],["大于res数组最后一个元素的右端点",{"2":{"71":1}}],["大于10",{"2":{"52":1}}],["大于",{"2":{"29":2}}],["从小到大",{"2":{"63":1}}],["从数组开头到当前字符串全部截取掉",{"2":{"60":1}}],["从树中的构造中可以看到",{"2":{"35":1}}],["从上面的4级台阶的例子",{"2":{"35":1}}],["从原数组的第一个元素进行遍历",{"2":{"29":1,"71":1}}],["从而跳过需要移除的节点",{"2":{"6":1}}],["button>",{"2":{"86":1}}],["button",{"2":{"86":1}}],["begin",{"2":{"66":8,"67":1}}],["be",{"2":{"49":1}}],["break",{"2":{"39":1,"66":2}}],["b",{"2":{"29":4,"69":1,"71":2}}],["boolean",{"2":{"13":1,"23":2}}],["合并后的数组中就包含了两个原始数组的所有元素",{"2":{"64":1}}],["合并后的数组的前一个元素",{"2":{"64":1}}],["合并数组",{"2":{"63":2}}],["合并区间",{"0":{"28":1,"70":1},"1":{"29":1,"30":1,"71":1,"72":1}}],["合并两个有序链表",{"0":{"15":1},"1":{"16":1,"17":1,"18":1}}],["肯定需要维护一个数字",{"2":{"27":1}}],["今天重新书写了这道题目",{"2":{"27":1}}],["复习",{"0":{"27":1}}],["复杂度分析",{"0":{"3":1,"7":1,"9":1,"11":1,"14":1,"18":1,"21":1,"26":1,"30":1,"33":1,"41":1,"47":1,"50":1,"53":1,"58":1,"62":1,"67":1,"72":1,"75":1,"78":1,"83":1},"2":{"38":1,"39":1,"56":1,"81":1}}],["element",{"2":{"86":1}}],["else",{"2":{"2":2,"13":2,"17":2,"25":2,"29":2,"46":1,"49":2,"64":1,"66":2,"71":1,"74":2}}],["extends",{"2":{"86":1}}],["export",{"2":{"74":1}}],["exports",{"2":{"71":1,"74":1}}],["evenmaxlen",{"2":{"66":4}}],["end",{"2":{"71":6}}],["en",{"2":{"50":1}}],["each",{"2":{"25":1}}],[">打印render后的内容",{"2":{"86":1}}],[">let",{"2":{"86":1}}],[">=",{"2":{"52":2,"64":1,"66":2}}],[">",{"2":{"25":2,"29":4,"32":4,"45":2,"46":1,"49":2,"66":2,"71":2,"77":4,"86":3}}],["alien",{"2":{"86":1}}],["am",{"2":{"86":2}}],["add",{"2":{"61":1}}],["addtwonumbers",{"2":{"52":2}}],["arr",{"2":{"60":10,"62":2,"74":22}}],["array",{"2":{"8":1,"25":1,"49":2,"74":2}}],["as",{"2":{"49":1}}],["and",{"2":{"49":1}}],["anotherone",{"2":{"39":4}}],["ans",{"2":{"25":8}}],["abs",{"2":{"32":2,"77":2}}],["a",{"2":{"29":4,"69":1,"71":2}}],["after",{"2":{"25":1}}],["上面的第二条和第三条可以举个例子来说",{"2":{"25":1}}],["gt",{"2":{"25":1,"42":1,"44":1,"56":3,"64":1,"81":3}}],["get方法的实现思路比较简单",{"2":{"49":1}}],["get",{"2":{"13":2,"39":2,"40":1,"49":6,"50":2}}],["getlength",{"2":{"6":2}}],["题目描述",{"2":{"51":1,"63":1}}],["题目的要求是如果本身map中存在这个key",{"2":{"49":1}}],["题目中有一个隐藏的条件没有显示出来",{"2":{"49":1}}],["题目中已经给了前提条件",{"2":{"20":1}}],["题目要求",{"2":{"49":1}}],["题目只要求返回结果",{"2":{"25":1}}],["其实滑动窗口可以看成一个队列",{"2":{"60":1,"74":1}}],["其实开始的时候并不是很明白为什么需要使用for循环去枚举nums",{"2":{"23":1}}],["其中m和n分别是两个数组的长度",{"2":{"64":1}}],["其中每个子数组表示一种排列结果",{"2":{"23":1}}],["其中",{"2":{"14":1,"18":1,"21":2,"26":1,"30":2,"33":3,"38":1,"39":2,"41":2,"44":1,"50":1,"53":1,"58":1,"62":3,"72":2,"74":1,"75":2,"78":3,"83":1}}],["其中存储了三种右括号和对应的左括号的映射关系",{"2":{"13":1}}],["其中l是链表的长度",{"2":{"7":1,"9":2}}],["说明产生了重复",{"2":{"74":1}}],["说明已经存在",{"2":{"74":1}}],["说明存在了",{"2":{"74":1}}],["说明区间有交集",{"2":{"71":1}}],["说明进制为1",{"2":{"52":1}}],["说明有区间有交集",{"2":{"29":1}}],["说明这个数组可以直接放进merge数组中",{"2":{"29":1}}],["说明一次循环已经结束了",{"2":{"23":1}}],["说明我们将字符串s",{"2":{"13":1}}],["比如题目中的abcabcbb",{"2":{"60":1,"74":1}}],["比如target是4",{"2":{"39":1}}],["比如",{"2":{"25":1}}],["比方说",{"2":{"23":1}}],["比较",{"2":{"20":1}}],["通过以上的逻辑",{"2":{"64":1}}],["通过",{"2":{"62":1}}],["通过维护一个数组",{"2":{"62":1}}],["通过上述这种找规律",{"2":{"35":1}}],["通过这道题目的题解中used的使用可以使用map结构查重",{"2":{"23":1}}],["通过不断选择和回溯的过程",{"2":{"23":1}}],["重复上述过程",{"2":{"74":1}}],["重复上面的步骤",{"2":{"20":1}}],["重新设置",{"2":{"23":1}}],["推出",{"2":{"23":1}}],["达到了边界条件",{"2":{"23":1}}],["进入这个队列",{"2":{"60":1,"74":1}}],["进入递归逻辑之后",{"2":{"23":2}}],["进位",{"2":{"52":2}}],["进行下一个元素的处理逻辑",{"2":{"23":1}}],["走进for循环",{"2":{"23":1}}],["继续递归下一层",{"2":{"23":1}}],["表示当前回文子串的长度",{"2":{"66":1}}],["表示当前递归到第几层",{"2":{"23":1}}],["表示两个非负的整数",{"2":{"51":1}}],["表示爬到第x级台阶的方案数",{"2":{"35":1}}],["表示修改后数组的新长度",{"2":{"20":1}}],["本身包含一个嵌套循环",{"2":{"67":1}}],["本质是一个栈",{"2":{"23":2}}],["本题删除值为val的节点需要分为两步",{"2":{"69":1}}],["本题可以使用快慢指针的思路求解",{"2":{"20":1}}],["本题是一道经典的双指针题目",{"2":{"2":1}}],["us",{"2":{"86":1}}],["used",{"2":{"23":22,"50":2}}],["update",{"2":{"25":1}}],["undefined",{"2":{"8":6,"66":1}}],["最坏情况下需要遍历整个窗口",{"2":{"75":1}}],["最坏情况下",{"2":{"74":1,"75":1}}],["最坏情况下数组中任意两个数都要被匹配一次",{"2":{"38":1}}],["最长无重复子数组",{"0":{"73":1},"1":{"74":1,"75":1}}],["最长回文子串",{"0":{"65":1},"1":{"66":1,"67":1}}],["最高位的进位问题要最后特殊处理一下",{"2":{"52":1}}],["最前面的2=2这个键值对就被作为不常用的数据删除了",{"2":{"49":1}}],["最大的利润",{"2":{"46":1}}],["最大子数组和",{"0":{"24":1},"1":{"25":1,"26":1,"27":1}}],["最容易想到的方法是枚举数组中的每一个数x",{"2":{"38":1}}],["最后根据iseven的值返回中位数",{"2":{"64":1}}],["最后将新链表的头结点返回出去就行",{"2":{"52":1}}],["最后",{"2":{"49":1,"57":1,"64":1,"82":1}}],["最后爬一级",{"2":{"35":2}}],["最后爬两级",{"2":{"35":1}}],["最后的边界检查是常数空间复杂度",{"2":{"33":1,"78":1}}],["最后的边界检查是常数时间复杂度",{"2":{"33":1,"78":1}}],["最后对于边界问题进行处理",{"2":{"32":1,"77":1}}],["最后一个右端点",{"2":{"29":1}}],["最后一个唯一元素的索引",{"2":{"20":1}}],["最终返回的是right",{"2":{"66":1}}],["最终返回的结果为ans",{"2":{"25":1}}],["最终每天都看做是买入时间最终能够得出结果",{"2":{"45":1}}],["最终的结果默认是数组的第一个元素",{"2":{"27":1}}],["最终的结果数组",{"2":{"23":2}}],["最终",{"2":{"23":1}}],["尝试其他的选择",{"2":{"23":1}}],["选择一个元素作为当前位置的元素",{"2":{"23":1}}],["深度优先搜索可以穷举出所有的排列方式",{"2":{"23":1}}],["深度优先搜索的关键是回溯",{"2":{"23":1}}],["深度优先搜索的基本思想是通过递归的方式探索所有可能的排列",{"2":{"23":1}}],["深度优先搜索是解决全排列问题的常用方法之一",{"2":{"23":1}}],["生成所有可能的排列方式",{"2":{"23":1}}],["全排列问题是要求给定一组元素",{"2":{"23":1}}],["全排列",{"0":{"22":1},"1":{"23":1}}],["每两个相加",{"2":{"52":1}}],["每次都加上当前的遍历到的数组元素",{"2":{"27":1}}],["每次比较sum和ans的大小",{"2":{"25":1}}],["每循环完毕一个数字就更新下返回值",{"2":{"25":1}}],["每个元素只会被访问一次",{"2":{"21":1}}],["每移动一次算一次值并和结果比较取较大的",{"2":{"2":1}}],["算法流程",{"2":{"69":1}}],["算法的时间复杂度应该为",{"2":{"63":1}}],["算法",{"2":{"50":1}}],["算法来代替",{"2":{"50":1}}],["算法没有使用额外的空间",{"2":{"26":1}}],["算法只使用了常数级别的额外空间",{"2":{"21":1,"62":1}}],["算法使用双指针",{"2":{"21":1}}],["算法思路",{"0":{"2":1,"5":1,"13":1,"16":1,"20":1,"23":1,"25":1,"29":1,"32":1,"35":1,"37":1,"44":1,"49":1,"52":1,"55":1,"60":1,"64":1,"66":1,"69":1,"71":1,"74":1,"77":1,"80":1},"1":{"6":1,"7":1,"8":1,"9":1,"10":1,"17":1,"38":1,"39":1,"40":1,"45":1,"46":1,"56":1,"57":1,"81":1,"82":1}}],["原始数组",{"2":{"23":1}}],["原本的数组",{"2":{"23":2}}],["原因如下",{"2":{"21":2}}],["原地删除重复出现的元素",{"2":{"20":1}}],["唯一元素的数量为",{"2":{"20":1}}],["处理成什么",{"2":{"86":1}}],["处理之后的结果如下图",{"2":{"57":1,"82":1}}],["处",{"2":{"20":1}}],["而中位数的位置是由k决定的",{"2":{"64":1}}],["而处理每个位置只需要",{"2":{"53":1}}],["而另外一个数字呢",{"2":{"39":1}}],["而每一个元素不能被使用两次",{"2":{"38":1}}],["而这里要统计方案总数",{"2":{"35":1}}],["而是直接遍历数字的每一位并进行操作",{"2":{"33":1,"78":1}}],["而是要进行sum",{"2":{"25":1}}],["而不是循环的终止条件",{"2":{"64":1}}],["而不是",{"2":{"32":1,"77":1}}],["而",{"2":{"20":1,"21":1}}],["函数执行",{"2":{"86":1}}],["函数",{"2":{"67":4}}],["函数的时间复杂度和空间复杂度都是",{"2":{"33":1,"78":1}}],["函数中的dfs函数用于进行深度优先搜索",{"2":{"23":1}}],["函数操作后",{"2":{"20":1}}],["函数需要返回修改后数组的新长度",{"2":{"20":1}}],["举例说明",{"2":{"20":1}}],["均指向数组的起始位置",{"2":{"20":1}}],["含有重复元素的已排序数组",{"2":{"20":1}}],["后继节点为",{"2":{"69":1}}],["后面",{"2":{"52":1}}],["后移一位",{"2":{"20":1}}],["后者",{"2":{"2":1}}],["间都是重复的值",{"2":{"20":1}}],["初始化",{"2":{"69":1}}],["初始化设置为0",{"2":{"46":1}}],["初始化设置一个非常大的值",{"2":{"46":1}}],["初始化两个指针",{"2":{"20":1}}],["初始阶段",{"2":{"20":1}}],["初始时都指向虚拟头节点",{"2":{"10":1}}],["详细动图解释",{"2":{"20":1}}],["所有可能的回文子串的中心位置",{"2":{"66":1}}],["所有其他操作的时间复杂度都是常数级别的",{"2":{"18":1}}],["所以需要减去1才能得到正确的回文子串长度",{"2":{"66":1}}],["所以需要额外的",{"2":{"33":1,"78":1}}],["所以翻转之后返回的应该是pre",{"2":{"56":1,"81":1}}],["所以这个操作要和get一样",{"2":{"49":1}}],["所以遍历数组",{"2":{"46":1}}],["所以我们在取当前结点值的时候",{"2":{"52":1}}],["所以我们可以在遍历链表的同时按从低到高的顺序直接相加",{"2":{"52":1}}],["所以我们可以列出如下式子",{"2":{"35":1}}],["所以我们用一个指针",{"2":{"52":1}}],["所以我们只需要在x后面的元素中寻找target",{"2":{"38":1}}],["所以",{"2":{"35":1,"42":1,"60":1,"74":1}}],["所以时间复杂度无法更优",{"2":{"33":1,"78":1}}],["所以空间复杂度仍然是",{"2":{"33":1,"78":1}}],["所以空间复杂度是",{"2":{"33":1,"78":1}}],["所以主要的时间开销是排序的",{"2":{"30":1,"72":1}}],["所以说下次循环不会",{"2":{"25":1}}],["所以slow指针的值实际上是数组中唯一元素的数量减去1",{"2":{"20":1}}],["所以为了防止空指针",{"2":{"17":1}}],["所以不管哪个链表是非空的",{"2":{"17":1}}],["所以如果字符串长度为奇数",{"2":{"13":1}}],["只要记住",{"2":{"56":1,"81":1}}],["只循环一遍能够保证",{"2":{"40":1}}],["只能遍历一个数字",{"2":{"39":1}}],["只能从",{"2":{"35":1}}],["只有",{"2":{"35":1}}],["只有一个元素会被放进合并链表中",{"2":{"18":1}}],["只需一次遍历即可完成操作",{"2":{"10":1}}],["只需要额外的常数级别的空间",{"2":{"3":1}}],["会频繁的使用l1",{"2":{"17":1}}],["会减小",{"2":{"2":1}}],["方便操纵",{"2":{"86":1}}],["方便学习掌握以下内容",{"2":{"86":1}}],["方便移动",{"2":{"17":1}}],["方法查找当前元素是否在窗口中",{"2":{"75":1}}],["方法名",{"2":{"74":2}}],["方法更改原数组",{"2":{"60":1}}],["方法将其删除",{"2":{"50":1}}],["方法获取第一个键",{"2":{"50":1}}],["方法完成",{"2":{"50":1}}],["方法三",{"0":{"10":1,"40":1}}],["方法二",{"0":{"8":1,"39":1,"46":1,"57":1,"82":1}}],["方法一",{"0":{"6":1,"17":1,"38":1,"45":1,"56":1,"81":1},"2":{"13":1,"25":1}}],["由于函数",{"2":{"67":1}}],["由于节点没有引用其上一个节点",{"2":{"56":1,"81":1}}],["由于链表可能为空",{"2":{"52":1}}],["由于",{"2":{"52":1}}],["由于map是常数级查找效率",{"2":{"39":1}}],["由于暴力搜索的方法是遍历所有的两个数字的组合",{"2":{"39":1}}],["由于数组的索引是从0开始的",{"2":{"20":1}}],["由于输入的两个链表都是有序的",{"2":{"17":1}}],["由于后面遇到的",{"2":{"13":1}}],["至多有一个是非空的",{"2":{"17":1}}],["向后移一位",{"2":{"17":1}}],["要返回的字符串的长度",{"2":{"60":1,"61":1}}],["要存储这种形式的数据结构使用",{"2":{"49":1}}],["要么从n",{"2":{"35":2}}],["要考虑的边界条件是链表节点为空的场景",{"2":{"17":1}}],["要先闭合",{"2":{"13":1}}],["执行的操作都是常数时间复杂度的",{"2":{"14":1}}],["是这种形式",{"2":{"71":1}}],["是链表的长度",{"2":{"58":1,"83":1}}],["是指向null的前一个元素",{"2":{"56":1,"81":1}}],["是缓存中存储的键值对数量",{"2":{"50":1}}],["是一个类",{"2":{"49":1}}],["是数组中的元素数量",{"2":{"38":1,"39":2,"41":2}}],["是数组的长度",{"2":{"21":1,"26":1,"62":1}}],["是输入字符串",{"2":{"62":2}}],["是输入字符串的长度",{"2":{"14":1}}],["是输入数字的位数",{"2":{"33":3,"78":3}}],["是关键字",{"2":{"25":1}}],["是拼接两个链表中的所有节点",{"2":{"17":1}}],["是左括号",{"2":{"13":1}}],["是右括号",{"2":{"13":1}}],["若",{"2":{"52":1}}],["若存在",{"2":{"52":1}}],["若为空则取",{"2":{"52":1}}],["若不同",{"2":{"20":1}}],["若匹配成功",{"2":{"13":1}}],["若是",{"2":{"13":1}}],["中心点",{"2":{"66":1}}],["中心位置是两个相邻的字符",{"2":{"66":1}}],["中心位置是一个字符",{"2":{"66":1}}],["中心扩散法",{"2":{"66":1}}],["中当前元素",{"2":{"64":2}}],["中还有剩余元素",{"2":{"64":1}}],["中位数",{"2":{"63":3}}],["中",{"2":{"61":1}}],["中存在",{"2":{"61":1}}],["中存在对应的映射关系",{"2":{"13":1}}],["中存储的数据顺序是",{"2":{"49":1}}],["中是否包含这个元素",{"2":{"39":1}}],["中已经存放了",{"2":{"23":1}}],["中的元素已经全部加载完毕",{"2":{"64":1}}],["中的每个字符",{"2":{"13":1}}],["中的所有左括号闭合",{"2":{"13":1}}],["即head",{"2":{"57":1,"82":1}}],["即可",{"2":{"52":1,"69":2}}],["即为排序所需要的空间复杂度",{"2":{"30":1,"72":1}}],["即当当前路径的长度等于数组长度的时候",{"2":{"23":1}}],["即两个指针",{"2":{"21":1}}],["即位新数组的长度",{"2":{"20":1}}],["即",{"2":{"13":1,"20":1,"69":2}}],["对应的key的优先级是很高的",{"2":{"49":1}}],["对数组进行遍历",{"2":{"32":1,"77":1}}],["对结果有增益效果",{"2":{"25":1}}],["对输入字符串进行一次遍历即可判断括号序列是否合法",{"2":{"13":1}}],["对象",{"2":{"13":1,"74":1}}],["对于较长的字符串",{"2":{"67":1}}],["对于偶数来说",{"2":{"66":1}}],["对于奇数回文子串来说",{"2":{"66":1}}],["对于put方法来说",{"2":{"49":1}}],["对于每组",{"2":{"44":1}}],["对于每一个元素",{"2":{"41":1}}],["对于每一个元素x",{"2":{"39":1}}],["对于每个数字",{"2":{"23":1}}],["对于每个字符",{"2":{"14":1,"62":1}}],["对于边界条件0",{"2":{"32":1,"77":1}}],["对于结果无增益效果",{"2":{"25":1}}],["对于迭代方法来说",{"2":{"17":1}}],["对于",{"2":{"6":1}}],["的编译过程",{"2":{"86":1}}],["的前驱节点为",{"2":{"69":1}}],["的空间复杂度找到字符串中的最长回文",{"2":{"67":1}}],["的时候跳出",{"2":{"69":1}}],["的时候",{"2":{"66":2}}],["的时间复杂度和",{"2":{"67":1}}],["的时间复杂度",{"2":{"67":1}}],["的时间复杂度为",{"2":{"67":1}}],["的时间复杂度都是",{"2":{"62":1}}],["的时间",{"2":{"53":1}}],["的正序",{"2":{"63":1}}],["的长度",{"2":{"62":2}}],["的结点",{"2":{"52":1}}],["的方式存储的",{"2":{"51":1}}],["的链表",{"2":{"51":1}}],["的",{"2":{"13":1}}],["的下一个节点",{"2":{"10":1}}],["的下一个节点不为空",{"2":{"8":1}}],["一",{"0":{"86":1}}],["一直维持这样的队列",{"2":{"60":1,"74":1}}],["一位",{"2":{"51":1}}],["一次遍历",{"0":{"46":1}}],["一般来说",{"2":{"39":1}}],["一级",{"2":{"35":1}}],["一级台阶也没有的情况",{"2":{"35":1}}],["一级一级的爬",{"2":{"35":2}}],["一个道理",{"2":{"66":1}}],["一个是put方法",{"2":{"49":1}}],["一个是get方法",{"2":{"49":1}}],["一个记录元素是否使用过的哈希表",{"2":{"23":1}}],["一个记录是否使用过的hash表",{"2":{"23":1}}],["一个栈",{"2":{"23":1}}],["一个排列中的数字已经选择够了",{"2":{"23":2}}],["一个虚拟头结点的创建非常必要",{"2":{"17":1}}],["一定存在无法匹配的情况",{"2":{"13":1}}],["一种是取不到",{"2":{"49":1}}],["一种是取不到值",{"2":{"49":1}}],["一种是能够取得到",{"2":{"49":1}}],["一种是能够取到值",{"2":{"49":1}}],["一种容易想到的方法是",{"2":{"6":1}}],["一种常用的技巧是添加一个",{"2":{"5":1}}],["获取字符串的长度",{"2":{"13":1}}],["获取栈顶元素",{"2":{"8":1}}],["首先处理边界条件",{"2":{"66":1}}],["首先计算两个数组的长度",{"2":{"64":1}}],["首先sum就是两个节点的值添加上进制",{"2":{"52":1}}],["首先设置最大的利润为0",{"2":{"45":1}}],["首先我们从最简单的思路入手",{"2":{"45":1}}],["首先需要将数字转换成字符串并存储",{"2":{"33":1,"78":1}}],["首先判断递归终止条件",{"2":{"23":1}}],["首先",{"2":{"13":1,"17":1,"29":1,"71":1}}],["首先创建一个虚拟头节点",{"2":{"10":1}}],["用一个循环依次比较两个指针的位置",{"2":{"64":1}}],["用两个指针",{"2":{"64":1}}],["用target减去遍历到的数字",{"2":{"39":1}}],["用来存储最终的结果返回",{"2":{"29":1,"71":1}}],["用来简化处理从链表尾部移除节点的情况",{"2":{"6":1}}],["用于存储所有的排列结果",{"2":{"23":1}}],["用于存储所有的结果",{"2":{"23":1}}],["用于存储当前的路径",{"2":{"23":2}}],["用于存储左括号",{"2":{"13":1}}],["用于检查给定的字符串中的括号是否合法",{"2":{"13":1}}],["否则表示数组nums2还有剩余元素或者nums1的当前元素大于等于nums2的当前元素nums2",{"2":{"64":1}}],["否则翻转之后找不到了",{"2":{"56":1,"81":1}}],["否则为",{"2":{"52":1}}],["否则取结点值",{"2":{"52":1}}],["否则",{"2":{"13":2,"17":1,"23":1,"29":1,"71":1}}],["否则返回",{"2":{"13":1}}],["则执行",{"2":{"69":2}}],["则将合并后数组中两个相邻元素的平均值作为中位数返回",{"2":{"64":1}}],["则将栈顶元素出栈",{"2":{"13":1}}],["则再建一个值为",{"2":{"52":1}}],["则指向下一个位置",{"2":{"52":1}}],["则sum直接更新为当前遍历数字",{"2":{"25":1}}],["则sum保留并加上当前遍历的数字",{"2":{"25":1}}],["则说明",{"2":{"25":2}}],["则说明链表长度为",{"2":{"8":1}}],["则说明链表长度小于等于",{"2":{"8":1}}],["则跳过该数字",{"2":{"23":1}}],["则fast指针后移一位",{"2":{"20":1}}],["则表示存在不匹配的情况",{"2":{"13":1}}],["则表示所有括号都正确匹配",{"2":{"13":2}}],["则直接返回合并后数组的中间元素作为中位数",{"2":{"64":1}}],["则直接返回",{"2":{"13":1}}],["遍历下一个节点",{"2":{"69":1}}],["遍历完成",{"2":{"60":1,"74":1}}],["遍历完毕整个数组之后最大利润就是我们想要求的值",{"2":{"46":1}}],["遍历字符串",{"2":{"60":1,"66":1,"74":1}}],["遍历字符串的时间复杂度为",{"2":{"14":1}}],["遍历了整个链表",{"2":{"58":1,"83":1}}],["遍历一遍数组",{"2":{"39":1}}],["遍历得到了一个2",{"2":{"39":1}}],["遍历数组一次",{"2":{"26":1}}],["遍历数组",{"2":{"25":1,"45":1,"47":1,"74":1}}],["遍历结束返回结果",{"2":{"25":1}}],["遍历结束后",{"2":{"13":2}}],["遍历过的元素直接跳出",{"2":{"23":1}}],["遍历到当前元素的时候",{"2":{"40":1}}],["遍历到",{"2":{"23":1}}],["遍历输入字符串",{"2":{"13":1}}],["遍历链表",{"2":{"6":1,"8":1,"69":1}}],["https",{"2":{"50":1,"67":1}}],["has",{"2":{"13":2,"39":1,"40":1,"49":4,"61":1,"74":2}}],["hello",{"2":{"86":1}}],["helper",{"2":{"66":6,"67":5}}],["head",{"2":{"6":7,"8":2,"10":2,"56":3,"57":21,"69":13,"81":3,"82":21}}],["height",{"2":{"2":19}}],["省去后续的遍历判断过程",{"2":{"13":1}}],["值为相同类型的左括号",{"2":{"13":1}}],["时候",{"2":{"69":1}}],["时候跳出",{"2":{"69":1}}],["时间内完成",{"2":{"50":1}}],["时间复杂度从",{"2":{"74":1}}],["时间复杂度主要取决于用于检查回文字符的嵌套循环",{"2":{"67":1}}],["时间复杂度是o",{"2":{"56":1,"81":1}}],["时间复杂度仍然是",{"2":{"50":1}}],["时间复杂度的算法",{"2":{"38":1}}],["时间复杂度分析",{"2":{"21":1,"62":1,"74":1}}],["时间复杂度为",{"2":{"11":1,"50":4,"67":1,"74":1,"75":4}}],["时间复杂度",{"2":{"3":1,"7":1,"9":1,"14":1,"18":1,"26":1,"30":1,"33":1,"38":1,"39":1,"41":1,"47":1,"50":1,"53":1,"56":1,"58":1,"67":2,"72":1,"75":1,"78":1,"81":1,"83":1}}],["时",{"2":{"13":1}}],["左边界向左",{"2":{"66":1}}],["左右括号的数量必须相等",{"2":{"13":1}}],["左右两个指针分别指向数组的左右两侧",{"2":{"2":1}}],["左括号",{"2":{"13":2}}],["当应删除头节点",{"2":{"69":1}}],["当right",{"2":{"66":1}}],["当left和right所在的位置不相等时",{"2":{"66":1}}],["当left",{"2":{"66":1}}],["当遇到第二个a的时候",{"2":{"60":1}}],["当再进入一个a",{"2":{"60":1,"74":1}}],["当考虑完所有天数之时",{"2":{"46":1}}],["当我们使用遍历整个数组的方式寻找target",{"2":{"38":1}}],["当我们遇到一个右括号时",{"2":{"13":1}}],["当我们遇到一个",{"2":{"13":1}}],["当处理完当前位置的元素后",{"2":{"23":1}}],["当前指针指向前置节点",{"2":{"56":1,"81":1}}],["当前区间的左端点小于等于最后一个元素的右端点",{"2":{"29":1}}],["当前的节点接在",{"2":{"17":1}}],["当前节点的值小于等于",{"2":{"17":1}}],["当前字符是左括号",{"2":{"13":1}}],["当一个节点被添加到结果中之后",{"2":{"17":1}}],["当",{"2":{"17":1,"20":1,"69":1}}],["当遍历到l",{"2":{"6":1}}],["当遍历到第l",{"2":{"6":1}}],["栈的空间复杂度为",{"2":{"14":1}}],["栈的最大长度不会超过输入字符串的长度",{"2":{"14":1}}],["栈顶元素与当前右括号匹配",{"2":{"13":1}}],["栈",{"2":{"13":2}}],["有利于便捷使用",{"2":{"86":1}}],["有利于后续理解",{"2":{"86":1}}],["有很多重复的部分",{"2":{"35":1}}],["有4级台阶",{"2":{"35":1}}],["有3级台阶",{"2":{"35":1}}],["有2级台阶",{"2":{"35":1}}],["有1级台阶",{"2":{"35":1}}],["有一种方法",{"2":{"35":1}}],["有一个相同类型的",{"2":{"13":1}}],["有一部分的代码需要稍微解释和梳理一下",{"2":{"8":1}}],["有效的括号",{"0":{"12":1},"1":{"13":1,"14":1}}],["指向",{"2":{"69":1}}],["指向某个节点",{"2":{"69":1}}],["指向同一个位置",{"2":{"20":1}}],["指向链表的末尾",{"2":{"10":1}}],["指针仅在发现新元素时移动",{"2":{"21":1}}],["指针从头到尾遍历整个数组",{"2":{"21":1}}],["指针停留在索引",{"2":{"20":1}}],["指针移动到数组的最后一个唯一元素时",{"2":{"20":1}}],["指针表示修改后数组中的最后一个唯一元素的索引",{"2":{"20":1}}],["指针现在表示修改后数组的最后一个唯一元素",{"2":{"20":1}}],["指针到下一个位置",{"2":{"20":1}}],["指针所在位置的元素更新为",{"2":{"20":1}}],["指针所指元素",{"2":{"20":1}}],["指针所指元素相同",{"2":{"20":1}}],["指针所指元素是否与",{"2":{"20":1}}],["指针右移一位",{"2":{"20":1}}],["指针遍历数组",{"2":{"20":1}}],["指针往后移一位",{"2":{"17":1}}],["指针指向的节点就是需要删除的节点的前驱节点",{"2":{"10":1}}],["指针指向链表的最后一个节点",{"2":{"10":1}}],["指针指向链表的头节点",{"2":{"5":1}}],["指针",{"2":{"10":3}}],["指针领先",{"2":{"10":1}}],["指针比",{"2":{"10":1}}],["指针向前移动",{"2":{"10":1}}],["指针之间的距离",{"2":{"2":2}}],["然后用两个指针",{"2":{"64":1}}],["然后找到中位数",{"2":{"64":1}}],["然后通过",{"2":{"62":1}}],["然后将max更新为当前最长子串的长度",{"2":{"60":1,"74":1}}],["然后将当前字符push进数组",{"2":{"60":1,"74":1}}],["然后返回新的头结点",{"2":{"57":1,"82":1}}],["然后以",{"2":{"52":1}}],["然后更新",{"2":{"52":1}}],["然后把两个结点值相加",{"2":{"52":1}}],["然后把输入的两个链表从头往后撸",{"2":{"52":1}}],["然后使用",{"2":{"50":1}}],["然后再添加",{"2":{"49":1}}],["然后再遍历一遍",{"2":{"39":1}}],["然后在每一天考虑这么一个问题",{"2":{"46":1}}],["然后算其和",{"2":{"39":1}}],["然后需要将字符串转换成数组存储",{"2":{"33":1,"78":1}}],["然后分割成数组",{"2":{"32":1,"77":1}}],["然后我们将第一个区间加入",{"2":{"29":1,"71":1}}],["然后它肯定对结果是减益的",{"2":{"25":1}}],["然后回溯",{"2":{"23":1}}],["然后递归地处理剩余的元素",{"2":{"23":1}}],["然后可以遵循以下步骤移动指针",{"2":{"20":1}}],["然后",{"2":{"17":1,"23":1,"52":1,"66":1}}],["然后同时移动",{"2":{"10":1}}],["然后两个指针向中间搜索",{"2":{"2":1}}],["步",{"2":{"10":3}}],["和当前元素",{"2":{"64":1}}],["和对10取余",{"2":{"52":1}}],["和常数个辅助变量",{"2":{"21":1}}],["和",{"2":{"10":3,"17":3,"18":2,"20":4,"21":1,"35":1,"44":1,"47":1,"50":1,"52":1,"53":1,"62":1,"63":2,"64":4,"67":2,"74":1}}],["创建虚拟头节点",{"2":{"52":1}}],["创建合并数组",{"2":{"29":1,"71":1}}],["创建两个指针",{"2":{"10":1,"69":1}}],["创建一个新的链表的头节点",{"2":{"17":1}}],["创建一个新的节点并将它的下一个节点设为头节点",{"2":{"8":1}}],["创建一个空栈",{"2":{"13":1}}],["创建一个栈来存放链表中的节点",{"2":{"8":1}}],["创建一个",{"2":{"6":1,"13":1}}],["访问",{"2":{"10":1}}],["使每个元素只出现一次",{"2":{"20":1}}],["使得数组的长度等于字符串的长度",{"2":{"62":1}}],["使得",{"2":{"10":1}}],["使得逻辑更加统一",{"2":{"10":1}}],["使得链表的头节点可以通过",{"2":{"10":1}}],["使用了一个额外的数组",{"2":{"75":1}}],["使用了一个哈希表来存储窗口中的元素",{"2":{"74":1}}],["使用了一个栈",{"2":{"14":1}}],["使用两个指针",{"2":{"74":1}}],["使用哈希表优化后的算法时间复杂度为",{"2":{"74":1}}],["使用哈希表",{"2":{"74":1}}],["使用哈希表存储键值对",{"2":{"50":1}}],["使用的是start和end这个属性",{"2":{"71":1}}],["使用的额外空间",{"2":{"30":1,"72":1}}],["使用set数据结构配合滑动窗口能够提高效率",{"0":{"61":1}}],["使用这个api可以很方便的判断出是否在数组中出现过",{"2":{"60":1}}],["使用一个",{"2":{"74":1}}],["使用一个map数据结构",{"2":{"39":1}}],["使用一个栈存储",{"2":{"13":2}}],["使用",{"2":{"20":1,"60":1,"61":1,"67":1,"74":2,"75":1}}],["使用快慢指针的方式来解决这个问题会更加高效",{"2":{"10":1}}],["使用快慢指针",{"0":{"10":1}}],["使用栈",{"0":{"8":1}}],["具体做法如下",{"2":{"74":1}}],["具体实现",{"2":{"60":1,"74":1}}],["具体应该如何移动呢",{"2":{"60":1}}],["具体步骤如下",{"2":{"10":1,"64":1}}],["具体的思路是",{"2":{"35":1}}],["具体的",{"2":{"2":1}}],["将时间复杂度降低到",{"2":{"67":1}}],["将较小的元素加入到合并后的数组",{"2":{"64":1}}],["将较小的元素加入到合并后的数组中",{"2":{"64":1}}],["将较小的节点添加到结果中去",{"2":{"17":1}}],["将两个正序数组合并成一个有序数组",{"2":{"64":1}}],["将两个结点相加生成的新结点按顺序加到",{"2":{"52":1}}],["将字符加入",{"2":{"61":1}}],["将最新的元素放在最后",{"2":{"74":1}}],["将最新的字符放进去",{"2":{"60":1}}],["将最大值设置为ans",{"2":{"25":1}}],["将反转head指向的结点的代码完善之后",{"2":{"57":1,"82":1}}],["将head指向的节点的下一个节点置为null",{"2":{"57":1,"82":1}}],["将head节点赋值给",{"2":{"17":1}}],["将当前元素添加到窗口中",{"2":{"74":2}}],["将当前元素和它之前的元素全部截取",{"2":{"74":1}}],["将当前元素赋值给前一个元素",{"2":{"64":1}}],["将当前字符连它之前的元素全部删除掉",{"2":{"74":1}}],["将当前的节点的next指针改为指向前一个元素",{"2":{"56":1,"81":1}}],["将当前路径存入结果数组res中",{"2":{"23":1}}],["将cur移动到下一个节点",{"2":{"52":1}}],["将虚拟头结点赋值被cur",{"2":{"52":1}}],["将新的键值对插入到哈希表的末尾",{"2":{"50":1}}],["将想要获取的key对应的value找出来",{"2":{"49":1}}],["将计算过的节点",{"2":{"35":1}}],["将数组中每个值和对应的索引",{"2":{"39":1}}],["将数组拼接成数字的时间复杂度也是",{"2":{"33":1,"78":1}}],["将数组再变成number",{"2":{"32":1,"77":1}}],["将数组反转",{"2":{"32":1,"77":1}}],["将数组进行升序排序",{"2":{"29":1,"71":1}}],["将数字转换成字符串",{"2":{"77":1}}],["将数字转换成字符串然后再反转回来是最直观的解法",{"2":{"32":1}}],["将数字类型首先处理成不带符号的字符串",{"2":{"32":1,"77":1}}],["将变量都打印出来",{"2":{"23":1}}],["将该数字从路径中移除",{"2":{"23":1}}],["将该数字加入路径中",{"2":{"23":1}}],["将fast位置不重复的元素复制到slow指针所在的位置上",{"2":{"20":1}}],["将对应链表中的节点向后移动一位",{"2":{"17":1}}],["将其置为二者的较大值",{"2":{"29":1,"71":1}}],["将其压入栈中",{"2":{"13":2}}],["将其闭合",{"2":{"13":1}}],["将栈顶元素出栈",{"2":{"13":1}}],["将",{"2":{"8":1,"10":1,"20":2,"23":1}}],["将所有节点压入栈中",{"2":{"8":1}}],["没有需要删除的节点",{"2":{"8":1}}],["为数组长度",{"2":{"75":1}}],["为窗口的大小",{"2":{"75":1}}],["为最长子序列的长度",{"2":{"74":1,"75":1}}],["为空或者",{"2":{"69":1}}],["为中心偶数长度回文",{"2":{"67":1}}],["为中心奇数长度回文和以",{"2":{"67":1}}],["为abc",{"2":{"60":1,"74":1}}],["为值建立一个新结点",{"2":{"52":1}}],["为区间的数量",{"2":{"30":1,"72":1}}],["为",{"2":{"8":2,"20":1,"52":1,"67":1}}],["为了避免两个输入链表同时为空",{"2":{"52":1}}],["为了改变顺序",{"2":{"49":1}}],["为了减少时间的复杂度",{"2":{"39":1}}],["为了符合问题的要求",{"2":{"20":1}}],["为了不判断空节点的情况",{"2":{"17":1}}],["为了快速判断括号的类型",{"2":{"13":1}}],["为了方便删除操作",{"2":{"6":1}}],["为了与题目中的n保持一致",{"2":{"6":1}}],["可以开始让两个链表相加了",{"2":{"52":1}}],["可以使用动态规划算法来提高代码效率",{"2":{"67":1}}],["可以使用",{"2":{"50":1}}],["可以使用双向链表来代替哈希表",{"2":{"50":1}}],["可以使用哈希表的",{"2":{"50":1}}],["可以事先将其存储起来",{"2":{"39":1}}],["可以得出递推公式",{"2":{"35":1}}],["可以先通过找规律的方法来进行梳理",{"2":{"35":1}}],["可以合并的区间一定是连续的",{"2":{"29":1,"71":1}}],["可以按照这个思路去理解",{"2":{"2":1}}],["可能会导致空指针异常",{"2":{"8":1}}],["可能为",{"2":{"8":1}}],["让我们来分析一下",{"2":{"8":1}}],["x时候",{"2":{"38":1}}],["x",{"2":{"32":7,"35":10,"38":2,"39":1,"41":2,"77":7}}],["x26",{"2":{"8":4,"17":4,"39":2,"52":4,"64":2,"66":4,"69":2}}],["x3c",{"2":{"2":6,"6":1,"8":2,"10":1,"13":1,"17":2,"20":1,"29":2,"32":2,"35":1,"38":2,"39":3,"40":1,"45":4,"46":2,"49":1,"60":2,"61":1,"64":3,"66":5,"71":1,"74":4,"77":2,"86":20}}],["个键值对",{"2":{"50":1}}],["个节点",{"2":{"8":1}}],["个节点时候",{"2":{"6":1}}],["个元素",{"2":{"8":1}}],["弹出栈顶的",{"2":{"8":1}}],["删除节点",{"2":{"69":1}}],["删除链表的节点",{"0":{"68":1},"1":{"69":1}}],["删除链表的倒数第n个节点",{"0":{"4":1},"1":{"5":1,"6":1,"7":1,"8":1,"9":1,"10":1,"11":1}}],["删除滑动窗口里相同的字符以及相同字符前的字符",{"2":{"60":1}}],["删除从第一个a到第二个a之间的4个字符",{"2":{"60":1}}],["删除重复元素后数组的新长度",{"2":{"20":1}}],["删除有序数组中的重复项",{"0":{"19":1},"1":{"20":1,"21":1}}],["删除",{"2":{"10":1}}],["删除待删除的节点",{"2":{"8":1}}],["删除操作就变得十分方便了",{"2":{"8":1}}],["并更新最长子序列长度",{"2":{"74":1}}],["并利用这些解决方案来避免重复计算",{"2":{"67":1}}],["并在每一步中",{"2":{"62":1}}],["并以相同形式返回一个表示和的链表",{"2":{"51":1}}],["并且是有序的",{"2":{"64":1}}],["并且满足以下两个条件之一",{"2":{"64":1}}],["并且找到合并后数组的中位数",{"2":{"64":1}}],["并且每个节点只能存储",{"2":{"51":1}}],["并且目前栈顶的节点就是待删除节点的前驱节点",{"2":{"8":1}}],["并按照顺序依次考虑之后的每个区间",{"2":{"29":1,"71":1}}],["并标记为未使用",{"2":{"23":1}}],["并将左指针右移",{"2":{"74":3}}],["并将j增加1",{"2":{"64":1}}],["并将i增加1",{"2":{"64":1}}],["并将指针向后移动一位",{"2":{"64":1}}],["并将指针移动到下一位",{"2":{"64":1}}],["并将",{"2":{"20":1}}],["并将x的指针指向y的后继节点",{"2":{"5":1}}],["并返回合并链表即可",{"2":{"17":1}}],["并判断长度是否为奇数",{"2":{"13":1}}],["直接",{"2":{"52":1}}],["直接将map中的第一个元素删除掉",{"2":{"49":1}}],["直接将其下一个节点指向下下个节点即可完成删除操作",{"2":{"10":1}}],["直接在map中查找其是否存在即可",{"2":{"39":1}}],["直接拼接起来转换成数字即可",{"2":{"32":1,"77":1}}],["直接使用3这个元素",{"2":{"23":1}}],["直接跳过",{"2":{"23":1}}],["直接返回方法规定的值即可",{"2":{"74":2}}],["直接返回head",{"2":{"69":1}}],["直接返回",{"2":{"13":2,"50":1,"69":1}}],["直到遍历完整个数组",{"2":{"74":1}}],["直到left和right所在的字符不相等为止",{"2":{"66":1}}],["直到l1或者l2指向了null",{"2":{"17":1}}],["直到不相同为止",{"2":{"66":1}}],["直到找到中位数为止",{"2":{"64":1}}],["直到满足题目要求",{"2":{"60":1,"74":1}}],["直到所有元素都被处理完毕",{"2":{"23":1}}],["直到fast等于数组的长度",{"2":{"20":1}}],["直到",{"2":{"10":2,"69":1}}],["直到链表尾部",{"2":{"6":1}}],["直觉告诉我们",{"2":{"2":1}}],["返回链表头部节点",{"2":{"69":1}}],["返回链表的长度",{"2":{"6":1}}],["返回值",{"2":{"69":1}}],["返回max即可",{"2":{"60":1,"74":1}}],["返回的结果是翻转后的链表的头节点",{"2":{"57":3,"82":3}}],["返回一个空数组",{"2":{"29":1,"71":1}}],["返回一个二维数组res",{"2":{"23":1}}],["返回连续子数组的最大值",{"2":{"27":1}}],["返回所有的排列结果",{"2":{"23":1}}],["返回结果",{"2":{"39":1}}],["返回结果数组",{"2":{"23":1}}],["返回结果链表的头节点",{"2":{"8":1}}],["返回数组的新长度",{"2":{"20":1}}],["返回新的数组长度",{"2":{"20":1}}],["返回新的链表的头节点",{"2":{"6":1}}],["返回slow",{"2":{"20":1}}],["返回",{"2":{"13":7,"60":1}}],["返回int类型的变量",{"2":{"2":1}}],["节点等于",{"2":{"69":1}}],["节点1之后的节点",{"2":{"57":1,"82":1}}],["节点的后面同时将",{"2":{"17":1}}],["节点的编号从1开始",{"2":{"6":1}}],["节点",{"2":{"6":2,"69":1}}],["text",{"2":{"86":1}}],["textcomponent",{"2":{"86":3}}],["tolearn",{"2":{"86":2}}],["total",{"2":{"64":3}}],["tostring",{"2":{"32":1,"77":1}}],["tip",{"2":{"51":1}}],["twosum",{"2":{"38":1,"39":1,"40":1}}],["target",{"2":{"38":3,"39":4,"40":4}}],["the",{"2":{"25":1,"74":2}}],["through",{"2":{"25":1}}],["this",{"2":{"6":2,"17":4,"49":26,"52":4,"56":2,"69":2,"81":2,"86":3}}],["typescriptclass",{"2":{"49":1}}],["typescriptfunction",{"2":{"29":1,"32":1,"77":1}}],["typescript",{"2":{"23":1,"25":1}}],["true",{"2":{"13":3,"23":10}}],["ts",{"2":{"6":1,"8":1,"17":1,"20":1,"23":1,"39":1,"52":1,"74":1}}],["tsfunction",{"2":{"2":1,"13":1,"35":1,"45":1,"57":1,"60":1,"64":1,"66":1,"82":1}}],["component",{"2":{"86":2}}],["com",{"2":{"67":1}}],["console",{"2":{"71":2,"86":1}}],["const",{"2":{"13":6,"23":10,"25":3,"32":3,"40":1,"64":5,"77":3,"86":1}}],["constructor",{"2":{"6":1,"17":1,"49":1,"52":1}}],["continue",{"2":{"23":2}}],["carry",{"2":{"52":13}}],["cache",{"2":{"50":1}}],["called",{"2":{"49":1}}],["capacity",{"2":{"49":6}}],["climbstairs",{"2":{"35":4}}],["class",{"2":{"2":1,"6":1,"17":1,"52":1,"86":1}}],["children",{"2":{"86":1}}],["charat",{"2":{"60":1,"66":6}}],["ch",{"2":{"13":11}}],["currentlen",{"2":{"66":6}}],["curr分别保存上一个元素和当前的元素",{"2":{"64":1}}],["curr",{"2":{"64":6}}],["cur为null",{"2":{"56":1,"81":1}}],["cur节点",{"2":{"56":1,"81":1}}],["cur的下一个节点就是需要移除的节点",{"2":{"6":1}}],["cur",{"2":{"6":5,"8":5,"17":15,"52":13,"56":7,"57":6,"58":1,"69":21,"81":7,"82":6,"83":1}}],["cur指向",{"2":{"6":1}}],["||",{"2":{"13":2,"17":2,"32":4,"52":2,"57":1,"64":1,"66":1,"77":4,"82":1}}],["|",{"2":{"6":5,"8":3,"17":5,"52":5,"57":2,"82":2}}],["l++",{"2":{"64":1}}],["lfu",{"2":{"50":1}}],["last",{"2":{"49":4}}],["lrucache",{"2":{"49":7}}],["lru",{"0":{"48":1},"1":{"49":1,"50":1},"2":{"50":4}}],["longest",{"2":{"67":2}}],["longestpalindrome",{"2":{"66":2,"67":1}}],["log",{"2":{"63":1,"71":2,"86":1}}],["logn",{"2":{"30":2,"72":2}}],["loop",{"2":{"25":1}}],["lt",{"2":{"25":1,"56":3,"64":1,"81":3}}],["l2",{"2":{"17":13,"18":1,"52":16}}],["l1",{"2":{"17":13,"18":1,"52":16}}],["l",{"2":{"7":1,"9":2,"64":2}}],["list2",{"2":{"17":7}}],["list1",{"2":{"17":7}}],["listnode>",{"2":{"8":1}}],["listnode",{"2":{"6":9,"8":4,"10":1,"17":12,"52":16,"56":3,"57":8,"69":1,"81":3,"82":8}}],["list",{"2":{"6":1,"17":2,"52":2,"56":1,"69":1,"81":1}}],["linked",{"2":{"6":1,"17":2,"52":2,"56":1,"69":1,"81":1}}],["learn",{"2":{"86":1}}],["least",{"2":{"50":2}}],["leetcode那道题目给定的是一个字符串",{"2":{"74":1}}],["leetcode",{"2":{"67":1}}],["len",{"2":{"23":17,"66":2}}],["lengthoflongestsubstring",{"2":{"60":2,"61":1,"74":1}}],["length",{"2":{"2":3,"6":4,"13":8,"20":1,"23":2,"29":10,"38":1,"39":2,"40":1,"45":4,"46":1,"60":4,"61":1,"64":2,"66":6,"71":5,"74":6}}],["left和right已经分别移动了一位",{"2":{"66":1}}],["left和right分别代表当前回文子串的左右边界",{"2":{"66":1}}],["left向左移动",{"2":{"66":1}}],["left++",{"2":{"2":1,"61":1,"74":2}}],["left",{"2":{"2":5,"61":3,"66":15,"67":1,"74":6}}],["let",{"2":{"2":4,"6":5,"8":5,"10":4,"13":2,"17":4,"20":2,"25":4,"29":4,"32":3,"35":2,"38":4,"39":5,"40":2,"45":8,"46":3,"49":4,"52":8,"56":3,"57":6,"60":8,"61":4,"64":5,"66":13,"69":2,"71":2,"74":16,"77":3,"81":3,"82":6}}],["splice",{"2":{"60":3,"62":2,"74":2,"75":1}}],["split",{"2":{"32":2,"77":2}}],["substring",{"2":{"66":2,"67":2}}],["such",{"2":{"49":1}}],["sum第一次循环完就是",{"2":{"25":1}}],["sum",{"2":{"25":13,"52":9}}],["sum表示当前最大连续子序列和为sum",{"2":{"25":1}}],["size",{"2":{"49":2,"74":2}}],["singly",{"2":{"6":1,"17":2,"52":2,"56":1,"69":1,"81":1}}],["safe",{"2":{"46":1}}],["set",{"2":{"39":1,"40":1,"49":4,"50":1,"61":8,"74":2}}],["sort",{"2":{"29":2,"71":1}}],["solution",{"2":{"2":1}}],["slice",{"2":{"23":2}}],["slow++",{"2":{"20":1}}],["slow",{"2":{"10":11,"20":20,"21":2}}],["style=",{"2":{"86":1}}],["status",{"2":{"86":2}}],["start",{"2":{"71":4}}],["stack",{"2":{"8":4}}],["string>",{"2":{"13":1}}],["string",{"2":{"13":3,"32":1,"60":3,"66":5,"74":1,"77":1}}],["stk",{"2":{"13":15,"14":1}}],["s",{"2":{"13":7,"60":9,"61":5,"62":3,"66":27,"67":1,"74":1}}],["foot",{"2":{"86":1}}],["for",{"2":{"6":2,"8":1,"10":1,"13":2,"17":2,"23":2,"25":2,"29":2,"35":1,"38":2,"39":2,"40":1,"45":4,"46":1,"52":2,"56":1,"60":2,"61":1,"64":1,"66":2,"67":1,"69":1,"71":1,"74":2,"81":1}}],["fiber",{"2":{"86":1}}],["findmediansortedarrays",{"2":{"64":1}}],["floor",{"2":{"64":1,"66":2}}],["fragment>",{"2":{"86":2}}],["fragment",{"2":{"86":1}}],["frequently",{"2":{"50":1}}],["from",{"2":{"49":2}}],["f",{"2":{"35":6}}],["false",{"2":{"13":13,"23":3,"86":1}}],["fast++",{"2":{"20":1}}],["fast指针后移一位继续寻找不同的值",{"2":{"20":1}}],["fast指针所在的位置的元素是不重复的元素",{"2":{"20":1}}],["fast",{"2":{"10":14,"20":12,"21":2}}],["function",{"2":{"2":1,"6":2,"8":1,"10":1,"13":1,"17":3,"20":1,"23":4,"25":1,"29":1,"32":1,"35":1,"38":1,"39":1,"40":1,"45":1,"46":1,"49":3,"52":3,"56":2,"57":3,"60":1,"61":1,"66":3,"69":2,"71":1,"74":3,"77":1,"81":2,"82":3,"86":1}}],["div",{"2":{"86":2}}],["div>三元运算",{"2":{"86":1}}],["div>hello",{"2":{"86":1}}],["div>",{"2":{"86":10}}],["deletenode",{"2":{"69":1}}],["delete",{"2":{"49":6,"50":2,"61":1,"74":2}}],["depth",{"2":{"23":13}}],["definition",{"2":{"6":1,"17":2,"52":2,"56":1,"69":1,"81":1}}],["dfs",{"2":{"23":6}}],["dummyhead",{"2":{"17":3,"52":6}}],["dummy",{"2":{"5":1,"6":5,"8":4,"10":8,"52":3}}],["就应该从jsx入手",{"2":{"86":1}}],["就将其添加到窗口中",{"2":{"74":1}}],["就继续比较",{"2":{"64":1}}],["就返回中位数",{"2":{"64":1}}],["就可以实现删除",{"2":{"69":1}}],["就可以定位目标节点",{"2":{"69":1}}],["就可以写出完整的代码了",{"2":{"57":1,"82":1}}],["就可以得到如下的代码",{"2":{"57":1,"82":1}}],["就完成了整个链表的反转",{"2":{"57":1,"82":1}}],["就更新这个值",{"2":{"49":1}}],["就更新最大利润",{"2":{"46":1}}],["就能完成操作",{"2":{"6":1}}],["就是如何寻找起始位置",{"2":{"66":1}}],["就是无论是get访问还是put存储",{"2":{"49":1}}],["就是按照题目给出的执行顺序",{"2":{"49":1}}],["就是另外一个需要的数字了",{"2":{"39":1}}],["就是",{"2":{"6":1}}],["就是我们所说的左指针",{"2":{"2":1}}],["头节点为编号为1的节点",{"2":{"6":1}}],["注意返回值不计入空间复杂度",{"2":{"53":1}}],["注意题目中给定的要求",{"2":{"17":1}}],["注意到有效字符串的长度一定为偶数",{"2":{"13":1}}],["注意",{"2":{"6":1}}],["倒数第二个节点就是4",{"2":{"6":1}}],["+=",{"2":{"25":2}}],["++i",{"2":{"8":1}}],["++length",{"2":{"6":1}}],["+",{"2":{"6":5,"18":1,"20":6,"23":2,"25":1,"35":3,"38":2,"45":2,"52":4,"60":2,"61":1,"63":1,"64":2,"66":6,"67":1,"74":2}}],["得到链表的长度l",{"2":{"6":1}}],["但是时间复杂度较高",{"2":{"74":1}}],["但是时间复杂度高",{"2":{"39":1}}],["但是算法思路是一样的",{"2":{"74":1}}],["但是暴力法在时间复杂度上是比较高的",{"2":{"45":1}}],["但是这个算法的时间复杂度是",{"2":{"38":1}}],["但是需要注意对边界条件的处理",{"2":{"32":1,"77":1}}],["但是如果链表长度小于等于",{"2":{"8":1}}],["但如果我们添加了",{"2":{"5":1}}],["但由于头节点不存在前驱节点",{"2":{"5":1}}],["需要移除左指针元素",{"2":{"74":1}}],["需要减去1的原因是",{"2":{"66":1}}],["需要先记录下来当前节点的后指针",{"2":{"56":1,"81":1}}],["需要删除最近最少使用的键值对",{"2":{"50":1}}],["需要删除的节点为头节点",{"2":{"8":1}}],["需要删除的节点y有可能就是头节点",{"2":{"5":1}}],["需要将其删除",{"2":{"50":1}}],["需要将其删除并重新插入到哈希表的末尾",{"2":{"50":1}}],["需要将顺序放在最后面",{"2":{"49":1}}],["需要实现两个方法",{"2":{"49":1}}],["需要",{"2":{"47":1}}],["需要注意的是",{"2":{"39":1,"66":1}}],["需要注意到每一个位于x之前的元素都已经和x匹配过",{"2":{"38":1}}],["需要使用空间来换",{"2":{"39":1}}],["需要返回0",{"2":{"32":1,"77":1}}],["需要放入一个完整的排列了",{"2":{"23":1}}],["需要回溯到上一层",{"2":{"23":1}}],["需要定义两个指针分别指向数组的左右两端",{"2":{"2":1}}],["例如",{"2":{"5":1,"67":1}}],["它只需要知道它之后的所有节点反转之后的结果就可以了",{"2":{"57":1,"82":1}}],["它意味着爬到第",{"2":{"35":1}}],["它们的初始值是以当前字符为中心的回文子串的左右边界",{"2":{"66":1}}],["它们每位数字都是按照",{"2":{"51":1}}],["它们重合",{"2":{"29":1,"71":1}}],["它们可以容纳的水量为",{"2":{"2":1}}],["它接收以下的参数",{"2":{"23":1}}],["它使用了深度优先搜索的思想来生成所有可能的排列",{"2":{"23":1}}],["它从初始状态开始",{"2":{"23":1}}],["它包含的所有元素都比前面已经合并链表中的所有元素都要大",{"2":{"17":1}}],["它遵循以下步骤",{"2":{"13":1}}],["它是待删除节点的前一个节点",{"2":{"8":1}}],["它就是我们需要删除的节点",{"2":{"6":1}}],["它的下一个节点就是我们需要删除的节点",{"2":{"6":1}}],["它的",{"2":{"5":1}}],["哑节点",{"2":{"5":2}}],["在内层循环中",{"2":{"75":1}}],["在哈希表中添加",{"2":{"74":1}}],["在力扣上使用的是索引",{"2":{"71":1}}],["在helper函数中",{"2":{"66":1}}],["在head指向的结点为null或head指向的结点的下一个结点为null时停止",{"2":{"57":1,"82":1}}],["在枚举的过程中需要记录最长回文子串的相关变量",{"2":{"66":1}}],["在枚举的时候需要考虑回文子串的奇偶性",{"2":{"66":1}}],["在代码中",{"2":{"64":1}}],["在最坏情况下",{"2":{"62":3,"67":1,"75":1}}],["在最高点卖出",{"2":{"45":1}}],["在窗口右边放进新的字符",{"2":{"60":1}}],["在则删除滑动窗口数组里相同字符以及相同字符前的字符",{"2":{"60":1,"74":1}}],["在js中我们使用一个数组来维护滑动窗口",{"2":{"60":1,"74":1}}],["在java的解法中使用的是一个数组",{"2":{"23":1}}],["在更改引用前",{"2":{"56":1,"81":1}}],["在题目中我们只需要用一个变量记录一个历史的最低价格",{"2":{"46":1}}],["在做map映射的时候",{"2":{"42":1}}],["在dfs内部",{"2":{"23":1}}],["在递归的过程中",{"2":{"23":1}}],["在经过",{"2":{"20":1}}],["在这段代码中",{"2":{"64":1}}],["在这里对于节点1来说",{"2":{"57":1,"82":1}}],["在这个算法中",{"2":{"20":1}}],["在这种情况下",{"2":{"8":1}}],["在循环内部被调用两次",{"2":{"67":1}}],["在循环内部",{"2":{"67":1}}],["在循环条件结束的时候再判断这种情况",{"2":{"17":1}}],["在循环终止的时候",{"2":{"17":1}}],["在循环中我们用变量",{"2":{"64":1}}],["在循环中",{"2":{"8":1}}],["在遍历链表时",{"2":{"56":1,"81":1}}],["在遍历的过程中不断地更新最小值",{"2":{"46":1}}],["在遍历过程中",{"2":{"14":1,"47":1}}],["在遍历结束后",{"2":{"13":1}}],["在执行删除操作之前先进行了安全性检查",{"2":{"8":1}}],["在本题中",{"2":{"5":1}}],["在对链表进行操作时",{"2":{"5":1}}],["在初始阶段",{"2":{"2":1}}],["name",{"2":{"86":1}}],["nc78",{"0":{"79":1},"1":{"80":1,"81":1,"82":1,"83":1}}],["nc57",{"0":{"76":1},"1":{"77":1,"78":1}}],["nc41",{"0":{"73":1},"1":{"74":1,"75":1}}],["nc37",{"0":{"70":1},"1":{"71":1,"72":1}}],["nc298",{"0":{"68":1},"1":{"69":1}}],["n^2",{"2":{"38":2,"62":1,"67":4,"74":1,"75":2}}],["n为区间的数量",{"2":{"30":1,"72":1}}],["nlogn",{"2":{"30":2,"72":2}}],["n+m",{"2":{"18":1}}],["n+1",{"2":{"10":2}}],["newhead",{"2":{"17":3,"57":5,"82":5}}],["new",{"2":{"6":1,"8":1,"10":1,"13":2,"17":2,"39":1,"40":1,"49":3,"52":6,"61":1,"74":2}}],["next===undefined",{"2":{"6":1,"17":2,"52":2,"56":1,"81":1}}],["next",{"2":{"5":1,"6":10,"8":16,"10":9,"17":23,"50":1,"52":19,"56":7,"57":16,"58":1,"69":15,"81":7,"82":16,"83":1}}],["num",{"2":{"23":11,"25":8}}],["nums2",{"2":{"63":3,"64":7}}],["nums1",{"2":{"63":3,"64":7}}],["nums",{"2":{"20":9,"23":20,"25":8,"38":5,"39":6,"40":6}}],["number>",{"2":{"39":1,"49":1}}],["numbertoarray",{"2":{"32":4,"77":4}}],["number",{"2":{"2":7,"6":6,"8":1,"13":1,"17":2,"20":4,"23":14,"25":8,"29":5,"32":8,"35":5,"38":3,"39":4,"40":3,"45":6,"46":3,"49":12,"52":2,"60":4,"64":3,"66":3,"74":6,"77":8}}],["null",{"2":{"6":7,"8":8,"10":1,"17":11,"52":7,"56":3,"57":8,"66":1,"69":6,"81":3,"82":8}}],["nodejs",{"2":{"86":1}}],["node",{"2":{"5":1}}],["n",{"2":{"3":1,"6":5,"8":7,"10":3,"11":1,"13":4,"14":6,"18":2,"21":3,"26":2,"30":1,"33":12,"35":9,"38":5,"39":4,"41":4,"47":2,"50":4,"53":2,"56":2,"58":2,"62":5,"63":1,"64":4,"67":5,"72":1,"74":7,"75":6,"78":12,"81":2,"83":2}}],["onclick=",{"2":{"86":1}}],["oddmaxlen",{"2":{"66":4}}],["org",{"2":{"50":1}}],["obj",{"2":{"49":3}}],["object",{"2":{"49":1}}],["oo",{"2":{"30":1,"72":1}}],["of",{"2":{"13":2,"23":2,"25":2}}],["o",{"2":{"3":2,"7":2,"9":2,"11":2,"14":4,"18":3,"21":3,"26":2,"30":3,"33":11,"38":3,"39":3,"41":3,"47":2,"50":11,"53":3,"56":2,"58":2,"62":4,"63":1,"64":1,"67":12,"72":3,"74":11,"75":8,"78":11,"81":2,"83":2}}],["private",{"2":{"49":2}}],["prices",{"2":{"44":1,"45":11,"46":8,"47":1}}],["problems",{"2":{"67":1}}],["prototype",{"2":{"49":2}}],["profit",{"2":{"45":6}}],["pre",{"2":{"8":9,"56":6,"57":4,"58":1,"69":8,"81":6,"82":4,"83":1}}],["prev",{"2":{"8":9,"64":4}}],["pow",{"2":{"32":4,"77":4}}],["pop",{"2":{"8":2,"13":2,"23":2}}],["permute函数接收一个整数数组作为输入",{"2":{"23":1}}],["permute",{"2":{"23":2}}],["palindromic",{"2":{"67":2}}],["path",{"2":{"23":23}}],["pairs",{"2":{"13":8}}],["param",{"2":{"2":1,"17":2,"20":1,"23":13,"25":2,"29":1,"32":1,"35":1,"38":2,"39":2,"40":2,"45":1,"46":1,"49":5,"52":2,"56":1,"57":3,"60":1,"66":1,"74":3,"77":1,"81":1,"82":3}}],["put",{"2":{"49":3,"50":2}}],["push",{"2":{"8":1,"13":2,"23":4,"29":4,"39":2,"60":2,"71":2,"74":2}}],["public",{"2":{"2":1}}],["right向右移动",{"2":{"66":1}}],["right++",{"2":{"61":1,"66":2,"74":2}}],["right",{"2":{"2":6,"61":5,"66":12,"67":1,"74":12}}],["renderfoot",{"2":{"86":1}}],["renderfoot=",{"2":{"86":1}}],["render",{"2":{"86":2}}],["react",{"2":{"86":9}}],["react进阶学习",{"0":{"84":1}}],["recently",{"2":{"50":1}}],["reverselist",{"2":{"56":1,"57":8,"81":1,"82":8}}],["reverse",{"2":{"32":4,"77":4}}],["removeduplicates",{"2":{"20":2}}],["removenthfromend",{"2":{"6":1,"8":1,"10":1}}],["result",{"2":{"39":4}}],["resnumber",{"2":{"32":10,"77":10}}],["resarr",{"2":{"32":6,"77":6}}],["res之中",{"2":{"23":1}}],["res",{"2":{"2":13,"23":23,"29":20,"71":11,"74":10,"75":1}}],["returns",{"2":{"20":1}}],["return",{"2":{"2":4,"6":2,"8":1,"10":1,"13":6,"17":3,"20":1,"23":8,"25":5,"29":6,"32":5,"35":5,"38":3,"39":2,"40":3,"45":3,"46":2,"49":6,"52":3,"56":2,"57":7,"60":3,"61":1,"64":1,"66":8,"69":3,"71":3,"74":7,"77":5,"81":2,"82":7,"86":1}}],["不在窗口中",{"2":{"74":1}}],["不在则push进数组",{"2":{"60":1,"74":1}}],["不会使用任何额外的空间",{"2":{"67":1}}],["不会增加",{"2":{"2":1}}],["不随着输入规模的增加而增加",{"2":{"58":1,"83":1}}],["不随着输入规模的增加而增加额外的空间",{"2":{"21":1}}],["不要忘记在最后返回新的头引用",{"2":{"56":1,"81":1}}],["不要求得到最大的连续子数组是哪一个",{"2":{"25":1}}],["不需要重复计算了",{"2":{"35":1}}],["不断地选择下一个未被处理的元素",{"2":{"23":1}}],["不管我们将哪一个元素接在了后面",{"2":{"17":1}}],["不为",{"2":{"8":1}}],["不能重合",{"2":{"2":1}}],["j分别指向两个数组的开头",{"2":{"64":1}}],["j必须比i要大",{"2":{"45":1}}],["j++",{"2":{"38":1,"45":2,"64":1}}],["join",{"2":{"32":4,"77":4}}],["javascriptfunction",{"2":{"74":1}}],["javascriptvar",{"2":{"10":1,"61":1}}],["javascript",{"2":{"10":1,"49":1}}],["java",{"2":{"2":1}}],["j",{"2":{"2":12,"38":4,"44":3,"45":6,"64":9}}],["jsxconst",{"2":{"86":1}}],["jsx",{"0":{"86":1},"2":{"86":2}}],["jsfunction",{"2":{"71":1}}],["jsvar",{"2":{"13":1}}],["jsif",{"2":{"8":1}}],["js",{"2":{"2":1,"17":1,"23":1,"25":1,"29":1,"32":1,"35":1,"38":1,"40":1,"45":1,"46":1,"52":1,"56":1,"57":3,"60":1,"66":1,"69":1,"74":2,"77":1,"81":1,"82":3}}],["item",{"2":{"86":2}}],["item=>",{"2":{"86":1}}],["iteration",{"2":{"25":1}}],["iterate",{"2":{"25":1}}],["is",{"2":{"86":1}}],["iseven",{"2":{"64":3}}],["isvalid",{"2":{"13":3}}],["index",{"2":{"60":6,"74":6,"86":1}}],["indexof",{"2":{"60":3,"62":2,"74":2,"75":1}}],["instantiated",{"2":{"49":1}}],["int整型",{"2":{"74":2}}],["int整型一维数组",{"2":{"74":2}}],["interval",{"2":{"71":1}}],["intervals",{"2":{"29":19,"71":10}}],["integer",{"2":{"46":1}}],["int",{"2":{"2":3}}],["i++",{"2":{"2":2,"6":1,"10":1,"29":2,"35":1,"38":1,"39":2,"40":1,"45":2,"46":1,"60":2,"64":1,"66":2,"71":1,"74":2}}],["if",{"2":{"2":2,"8":1,"13":6,"17":2,"20":1,"23":4,"25":2,"29":6,"32":2,"35":2,"38":1,"39":1,"40":1,"45":2,"46":2,"49":6,"52":4,"57":1,"60":2,"64":1,"66":7,"69":3,"71":3,"74":4,"77":2,"82":1}}],["i",{"2":{"2":10,"6":2,"8":2,"10":2,"29":12,"35":5,"38":5,"39":9,"40":7,"44":3,"45":8,"46":10,"60":8,"64":10,"66":14,"67":3,"71":6,"74":8,"86":2}}],["00000",{"2":{"63":1}}],["02",{"0":{"51":1},"1":{"52":1,"53":1}}],["026",{"0":{"19":1},"1":{"20":1,"21":1}}],["07",{"0":{"31":1},"1":{"32":1,"33":1}}],["056",{"0":{"28":1},"1":{"29":1,"30":1}}],["053",{"0":{"24":1},"1":{"25":1,"26":1,"27":1}}],["019",{"0":{"4":1},"1":{"5":1,"6":1,"7":1,"8":1,"9":1,"10":1,"11":1}}],["0",{"2":{"2":6,"6":3,"8":2,"10":1,"13":3,"17":2,"20":2,"23":2,"25":8,"29":10,"32":7,"35":3,"38":1,"39":2,"40":1,"45":4,"46":3,"49":2,"51":2,"52":14,"56":1,"60":6,"61":3,"64":6,"66":8,"71":2,"74":12,"77":7,"81":1}}],["my",{"2":{"86":1}}],["module",{"2":{"71":1,"74":1}}],["m+n",{"2":{"63":1,"64":1}}],["memo",{"2":{"35":9}}],["merge数组最后一个元素的右端点",{"2":{"29":1}}],["merge",{"2":{"29":3,"71":3}}],["merged",{"2":{"29":1,"71":1}}],["mergetwolists",{"2":{"17":2}}],["m",{"2":{"18":2,"53":2,"63":1,"64":4,"74":2,"75":6}}],["margintop",{"2":{"86":1}}],["map",{"2":{"13":6,"39":7,"40":5,"49":28,"74":5,"86":1}}],["maxlength",{"2":{"74":5}}],["maxlen",{"2":{"60":4,"66":10,"67":1,"74":8}}],["maxprofit",{"2":{"45":10,"46":5,"47":1}}],["maxsubarray",{"2":{"25":2}}],["max",{"2":{"2":4,"25":2,"44":1,"46":1,"49":5,"53":1,"60":6,"61":5,"66":2,"74":12}}],["maxarea",{"2":{"2":3}}],["math",{"2":{"2":6,"25":2,"32":6,"60":2,"61":1,"64":1,"66":4,"74":4,"77":6}}],["minprice",{"2":{"46":7,"47":1}}],["min",{"2":{"2":3}}],["容量不够",{"2":{"49":1}}],["容器装水量的算法是找出左右两个边缘中较小的那个乘以两边的距离",{"2":{"2":1}}],["容纳水量是由",{"2":{"2":1}}],["因此整体时间复杂度为",{"2":{"67":1}}],["因此整体的时间复杂度是",{"2":{"58":1,"83":1}}],["因此函数",{"2":{"67":1}}],["因此函数返回",{"2":{"20":1}}],["因此额外空间复杂度是",{"2":{"62":1}}],["因此空间复杂度是",{"2":{"58":1,"83":1}}],["因此空间复杂度为",{"2":{"47":1,"50":1}}],["因此必须事先存储前一个元素",{"2":{"56":1,"81":1}}],["因此时间复杂度为",{"2":{"47":1}}],["因此不能进行重复匹配",{"2":{"38":1}}],["因此不需要执行删除操作",{"2":{"8":1}}],["因此遍历的总时间复杂度为",{"2":{"21":1}}],["因此总的时间复杂度为",{"2":{"18":1}}],["因此如果字符串的长度为奇数",{"2":{"13":1}}],["因此我们可以将这个左括号放入栈顶",{"2":{"13":1}}],["因此我们需要在删除头节点时进行特殊判断",{"2":{"5":1}}],["因此需要先进行判断",{"2":{"8":1}}],["因此",{"2":{"2":2,"14":1,"18":1,"20":1,"46":1,"62":2,"66":1,"67":1,"74":1,"75":1}}],["因为需要移动数组元素",{"2":{"75":1}}],["因为需要遍历数组",{"2":{"33":1,"78":1}}],["因为只需要用常数个变量来保存中间结果",{"2":{"64":1}}],["因为两个链表的长度可能会不一样",{"2":{"52":1}}],["因为每次只能爬",{"2":{"35":1}}],["因为每次循环迭代中",{"2":{"18":1}}],["因为这里没有采用任何类似于二分查找等高效算法",{"2":{"33":1,"78":1}}],["因为有了used这个映射的记录",{"2":{"23":2}}],["因为在这两种情况下",{"2":{"57":1,"82":1}}],["因为在内部的循环中",{"2":{"17":1}}],["因为在有效的括号序列中",{"2":{"13":1}}],["因为",{"2":{"2":1}}],["那么就将nums1中当前元素nums1",{"2":{"64":1}}],["那么最大利润的差值一定在",{"2":{"46":1}}],["那么我今天卖出能赚多少钱",{"2":{"46":1}}],["那么我们在第",{"2":{"46":1}}],["那么另外一个2不能是之前的那个2",{"2":{"39":1}}],["那么他们不会重合",{"2":{"29":1,"71":1}}],["那么在排完序的数组中",{"2":{"29":1,"71":1}}],["那么在栈中可能没有",{"2":{"8":1}}],["那么重复的元素一定会相邻",{"2":{"20":1}}],["那么字符串s无效",{"2":{"13":1}}],["那么头节点的前驱节点就是哑节点本身",{"2":{"5":1}}],["那么这个乘积会减小",{"2":{"2":1}}],["那么前者",{"2":{"2":1}}],["应该移动数字较小的那个",{"2":{"2":1}}],["这点要尤其注意",{"2":{"71":1}}],["这点要特别注意",{"2":{"32":1,"77":1}}],["这几个指针",{"2":{"58":1,"83":1}}],["这道题好就好在最低位在链表的开头",{"2":{"52":1}}],["这道题目给定的是一个数组",{"2":{"74":1}}],["这道题目和leetcode上面的第3题非常类似",{"2":{"74":1}}],["这道题目主要用到的思想是",{"2":{"60":1}}],["这道题目是一道比较基础的链表方面的题目",{"2":{"52":1}}],["这道题目在牛客上在访问数组元素的时候",{"2":{"71":1}}],["这道题目在牛客平台上测试用例看起来更加严谨",{"2":{"32":1,"77":1}}],["这道题目在添加的方法中",{"2":{"49":1}}],["这道题目的本质是获取元素的下标",{"2":{"42":1}}],["这道题目",{"2":{"32":1,"77":1}}],["这道题目中的",{"2":{"25":1}}],["这两个数都不会以",{"2":{"51":1}}],["这可以通过哈希表的",{"2":{"50":1}}],["这种优化后的解法效率更高",{"2":{"74":1}}],["这种方法可能会变得计算成本高昂",{"2":{"67":1}}],["这种方法只需一次遍历链表",{"2":{"11":1}}],["这种形式",{"2":{"49":1}}],["这些重复的部分是可以进行优化的",{"2":{"35":1}}],["这题是动态规划问题",{"2":{"35":1}}],["这里面有一个细节",{"2":{"66":1}}],["这里面最核心的逻辑就是通过for循环来将两个排序的数组合并成一个有序数组",{"2":{"64":1}}],["这里有一个很关键的点",{"2":{"49":1}}],["这里的minprice是遍历到i位置时候产生的最小值",{"2":{"46":1}}],["这里的j非常有讲究",{"2":{"45":1}}],["这里补充一个细节描述",{"2":{"46":1}}],["这里我们想要使用线性的时间复杂度来解决问题",{"2":{"39":1}}],["这里使用或运算符",{"2":{"52":1}}],["这里使用三目运算符",{"2":{"32":1,"77":1}}],["这里使用了反转数组的api",{"2":{"32":1,"77":1}}],["这里计算的是存储答案之外",{"2":{"30":1,"72":1}}],["这里定义一个变量res",{"2":{"29":1,"71":1}}],["这里为了方便的观察到递归的过程",{"2":{"23":1}}],["这里需要做防空处理",{"2":{"17":1}}],["这已经算是一种解题技巧了",{"2":{"17":1}}],["这意味着我们只需要简单地将非空链表接在合并链表的后面",{"2":{"17":1}}],["这段代码使用了单循环",{"2":{"58":1,"83":1}}],["这段代码是一个用于求解数组的全排列的函数",{"2":{"23":1}}],["这段代码利用栈的特性来判断括号的匹配情况",{"2":{"13":1}}],["这段代码实现了一个函数",{"2":{"13":1}}],["这段代码中的条件判断主要是为了确保在执行删除操作时不会发生错误",{"2":{"8":1}}],["这一数据结构来解决",{"2":{"13":1}}],["这将移动到待删除节点的前一个节点",{"2":{"8":1}}],["这行代码将cur的下一个节点设置为需要移除节点的下一个节点",{"2":{"6":1}}],["这样查找和删除操作的时间复杂度都可以降低到",{"2":{"74":1}}],["这样再执行put",{"2":{"49":1}}],["这样在遍历数组的时候",{"2":{"39":1}}],["这样虽然节省了空间",{"2":{"39":1}}],["这样的问题通常使用动态规划解决",{"2":{"25":1}}],["这样可以保证生成所有可能的排列",{"2":{"23":1}}],["这样可以确保每个排列都被考虑到",{"2":{"23":1}}],["这样可以在最后让我们比较容易的返回新合成的链表",{"2":{"17":1}}],["这样可以处理头节点就是要删除的情况",{"2":{"10":1}}],["这样我们只需要修改一次指针",{"2":{"6":1}}],["这样一来",{"2":{"5":1,"8":1}}],["这是个数学问题",{"2":{"6":1}}],["这是我日常学习算法时候做的笔记",{"0":{"0":1}}],["这个优化后的算法使用了滑动窗口的思想和哈希表来存储窗口中的元素",{"2":{"74":1}}],["这个解法的时间复杂度为",{"2":{"75":1}}],["这个解法的时间复杂度是",{"2":{"64":1}}],["这个解法的思路是利用归并排序的思想",{"2":{"64":1}}],["这个变量用于不断的移动指针",{"2":{"56":1,"81":1}}],["这个变量表示当前程序递归到第几层",{"2":{"23":2}}],["这个也就是为什么在执行get的时候需要先删除再添加的原因",{"2":{"49":1}}],["这个操作的时候",{"2":{"49":1}}],["这个操作执行之后",{"2":{"49":1}}],["这个时候是没有交集的",{"2":{"71":1}}],["这个时候就已经不满足要求",{"2":{"60":1,"74":1}}],["这个时候肯定能够获取最大的利润",{"2":{"45":1}}],["这个时候我们需要移动指针",{"2":{"2":1}}],["这个关键字很重要",{"2":{"25":1}}],["这个数据",{"2":{"23":1}}],["这个元素",{"2":{"23":2}}],["这个条件判断主要是为了确保删除操作不会出现空指针异常",{"2":{"8":1}}],["这个条件判断主要是为了确保需要删除节点的前驱节点",{"2":{"8":1}}],["这个条件判断主要是为了确保",{"2":{"8":1}}],["这个链表",{"2":{"6":1}}],["这并不是我们期望的结果",{"2":{"2":1}}],["=>",{"2":{"25":1,"29":2,"86":3}}],["===1",{"2":{"35":1}}],["===",{"2":{"13":5,"23":2,"29":2,"32":2,"35":1,"38":1,"57":2,"64":1,"66":5,"69":3,"71":1,"77":2,"82":2}}],["==",{"2":{"8":7,"10":1,"13":2,"17":4,"20":1,"39":1,"52":1,"56":1,"57":1,"60":2,"66":1,"69":3,"74":2,"81":1,"82":1}}],["=",{"2":{"2":14,"6":11,"8":9,"10":11,"13":7,"17":21,"20":4,"23":34,"25":12,"29":7,"32":7,"35":8,"38":4,"39":5,"40":3,"44":1,"45":11,"46":5,"49":13,"52":26,"56":9,"57":17,"60":11,"61":6,"63":7,"64":15,"66":22,"67":1,"69":14,"71":4,"74":21,"75":1,"77":7,"81":9,"82":17,"86":3}}],["^",{"2":{"2":2}}],["70",{"0":{"34":1},"1":{"35":1}}],["7",{"2":{"2":2,"46":1,"66":1}}],["30",{"2":{"71":1}}],["31",{"2":{"32":4,"77":4}}],["3",{"0":{"59":1},"1":{"60":1,"61":1,"62":1},"2":{"2":1,"6":1,"20":4,"23":21,"25":1,"35":2,"46":1,"49":1,"56":2,"63":5,"64":1,"69":1,"81":2}}],["4个",{"2":{"66":1}}],["46",{"0":{"22":1},"1":{"23":1}}],["4",{"0":{"63":1},"1":{"64":1},"2":{"2":1,"6":1,"25":1,"35":1,"46":1,"63":2,"64":1,"69":1}}],["5和",{"2":{"66":1}}],["5个数",{"2":{"66":1}}],["5+1",{"2":{"66":1}}],["50000",{"2":{"63":1}}],["5",{"0":{"65":1},"1":{"66":1,"67":1},"2":{"2":1,"6":2,"25":1,"35":1,"46":1,"63":1,"66":1,"69":1}}],["2=2",{"2":{"49":1}}],["2阶爬两级",{"2":{"35":1}}],["2这两个元素都使用过了",{"2":{"23":1}}],["21",{"0":{"15":1},"1":{"16":1,"17":1,"18":1}}],["206",{"0":{"54":1},"1":{"55":1,"56":1,"57":1,"58":1}}],["20230913",{"2":{"42":1}}],["20220327",{"2":{"27":1}}],["20",{"0":{"12":1},"1":{"13":1,"14":1}}],["2",{"2":{"2":1,"6":2,"13":2,"20":4,"23":16,"25":2,"32":4,"35":12,"56":2,"63":11,"64":4,"66":4,"69":2,"77":4,"81":2}}],["6",{"2":{"2":1,"46":1,"66":1}}],["8",{"2":{"2":4,"66":1}}],["100px",{"2":{"86":1}}],["10",{"2":{"52":6,"71":1}}],["1=1",{"2":{"49":1}}],["146",{"0":{"48":1},"1":{"49":1,"50":1}}],["121",{"0":{"43":1},"1":{"44":1,"45":1,"46":1,"47":1}}],["1阶爬一级",{"2":{"35":1}}],["1个节点时候",{"2":{"6":1}}],["1个节点",{"2":{"6":1}}],["1",{"0":{"36":1},"1":{"37":1,"38":1,"39":1,"40":1,"41":1,"42":1},"2":{"2":5,"3":1,"6":5,"7":1,"10":1,"11":1,"13":4,"17":2,"18":1,"20":9,"21":1,"23":21,"25":4,"26":1,"29":18,"32":2,"33":2,"35":16,"38":2,"39":1,"41":1,"42":1,"45":4,"46":2,"47":1,"49":5,"50":10,"52":6,"53":2,"56":3,"58":1,"60":4,"61":1,"62":1,"63":5,"64":2,"66":11,"67":4,"69":2,"71":4,"74":6,"77":2,"78":2,"81":3,"83":1}}],["11",{"0":{"1":1},"1":{"2":1,"3":1}}],["盛水最多的容器",{"0":{"1":1},"1":{"2":1,"3":1}}]],"serializationVersion":2}';export{t as default};
