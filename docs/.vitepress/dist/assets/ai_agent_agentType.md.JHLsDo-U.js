import{_ as t,c as e,o as l,aj as a}from"./chunks/framework.K2WCgrB4.js";const b=JSON.parse('{"title":"什么是 Agent Type：按“决策方式与运行形态”给智能体分类","description":"","frontmatter":{},"headers":[],"relativePath":"ai/agent/agentType.md","filePath":"ai/agent/agentType.md"}'),i={name:"ai/agent/agentType.md"},n=a(`<h1 id="什么是-agent-type-按-决策方式与运行形态-给智能体分类" tabindex="-1">什么是 Agent Type：按“决策方式与运行形态”给智能体分类 <a class="header-anchor" href="#什么是-agent-type-按-决策方式与运行形态-给智能体分类" aria-label="Permalink to &quot;什么是 Agent Type：按“决策方式与运行形态”给智能体分类&quot;">​</a></h1><p>你说的没错：<strong>ReAct</strong> 通常被归为一种“反应式（reactive）”的 agent type。这里的 <strong>agent type</strong> 不是指某个具体框架或模型型号，而是一个更工程化的概念：<strong>用一组稳定的设计维度，描述一个 Agent 如何做决策、如何组织步骤、如何执行工具、如何维护状态</strong>。</p><p>换句话说，agent type 关注的是“行为范式”，而不是“组件清单”。组件回答“有什么”，类型回答“怎么跑”。</p><h2 id="_1-agent-type-到底在描述什么" tabindex="-1">1. Agent Type 到底在描述什么 <a class="header-anchor" href="#_1-agent-type-到底在描述什么" aria-label="Permalink to &quot;1. Agent Type 到底在描述什么&quot;">​</a></h2><p>一个 Agent 系统落地时，你总会遇到这些问题：</p><ul><li>它是先出全局计划，还是边做边想？</li><li>它每一步是靠模型自由发挥，还是走固定流程？</li><li>它如何使用工具：一次调用就结束，还是多轮迭代直到完成？</li><li>它的状态如何维护：会话内、跨会话，还是可恢复的任务状态机？</li><li>它需要多安全：哪些动作必须确认/审批？</li></ul><p>这些差异组合起来，就是不同的 agent type。你也可以把 agent type 理解为 Agent Loop 的“运行策略”。</p><h2 id="_2-关键分类维度-建议记住这-5-个" tabindex="-1">2. 关键分类维度（建议记住这 5 个） <a class="header-anchor" href="#_2-关键分类维度-建议记住这-5-个" aria-label="Permalink to &quot;2. 关键分类维度（建议记住这 5 个）&quot;">​</a></h2><p>为了避免“类型越列越多”，可以先用维度来理解差异：</p><ol><li><strong>决策风格</strong>：反应式（每轮决定下一步） vs 规划式（先计划再执行）</li><li><strong>流程约束</strong>：自由探索（LLM 主导） vs 工作流/图（系统主导）</li><li><strong>任务跨度</strong>：短任务（一次/几次工具调用） vs 长任务（可恢复、可观测、可中断续跑）</li><li><strong>知识依赖</strong>：内置知识为主 vs 检索增强（RAG）为主</li><li><strong>协作形态</strong>：单智能体 vs 多智能体分工（planner/executor/critic 等）</li></ol><p>下面按“工程上最常见、最有用”的方式列出主要 agent types。</p><h2 id="_3-反应式-reactive-react-的位置" tabindex="-1">3. 反应式（Reactive）：ReAct 的位置 <a class="header-anchor" href="#_3-反应式-reactive-react-的位置" aria-label="Permalink to &quot;3. 反应式（Reactive）：ReAct 的位置&quot;">​</a></h2><p><strong>定义</strong></p><ul><li>每一轮只做一件事：基于当前上下文决定“下一步动作”，执行后观察结果，再继续下一轮。</li></ul><p><strong>典型循环</strong></p><div class="language-mermaid vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">flowchart LR</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  I[输入/目标] --&gt; T[思考: 决定下一步]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  T --&gt; A[行动: 工具调用/回复]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  A --&gt; O[观察: 工具结果/反馈]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  O --&gt; T</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>代表范式</strong></p><ul><li>ReAct（Reason + Act）：用“推理 + 行动 + 观察”的方式推进任务。</li></ul><p><strong>适用场景</strong></p><ul><li>信息不完整、需要边探索边收敛的任务：排障、数据分析、调研、复杂代码修改等。</li></ul><p><strong>优缺点</strong></p><ul><li>优点：灵活，适应性强，容易接入工具；对不确定环境鲁棒。</li><li>缺点：可能绕路，成本不可控；如果缺少约束与观测，容易反复试错。</li></ul><h2 id="_4-规划式-plan-and-execute-deliberative-先计划后执行" tabindex="-1">4. 规划式（Plan-and-Execute / Deliberative）：先计划后执行 <a class="header-anchor" href="#_4-规划式-plan-and-execute-deliberative-先计划后执行" aria-label="Permalink to &quot;4. 规划式（Plan-and-Execute / Deliberative）：先计划后执行&quot;">​</a></h2><p><strong>定义</strong></p><ul><li>先产出一个相对完整的计划（步骤/依赖/验收），再按计划执行，并在必要时修正。</li></ul><p><strong>适用场景</strong></p><ul><li>目标清晰、步骤可预期、需要输出可审计计划的任务：项目搭建、迁移改造、文档生成流水线、批处理任务等。</li></ul><p><strong>优缺点</strong></p><ul><li>优点：结构化、可控、便于插入检查点（审批/验证/预算）。</li><li>缺点：计划可能基于错误假设；环境变化时需要频繁重规划。</li></ul><h2 id="_5-工作流-图编排-workflow-graph-state-machine-系统驱动的-agent" tabindex="-1">5. 工作流/图编排（Workflow / Graph / State Machine）：系统驱动的 Agent <a class="header-anchor" href="#_5-工作流-图编排-workflow-graph-state-machine-系统驱动的-agent" aria-label="Permalink to &quot;5. 工作流/图编排（Workflow / Graph / State Machine）：系统驱动的 Agent&quot;">​</a></h2><p><strong>定义</strong></p><ul><li>用固定节点与分支（状态机/有向图）表达流程，LLM 只在少数节点做判断或填参数。</li></ul><p><strong>适用场景</strong></p><ul><li>强合规、强可控、流程确定：客服工单、审批流、数据同步、发布流程等。</li></ul><p><strong>优缺点</strong></p><ul><li>优点：可预测、可审计、易治理；失败边界清晰。</li><li>缺点：灵活度低；流程改动需要工程维护。</li></ul><h2 id="_6-工具型-tool-first-tool-using-把-llm-当-调度器" tabindex="-1">6. 工具型（Tool-First / Tool-Using）：把 LLM 当“调度器” <a class="header-anchor" href="#_6-工具型-tool-first-tool-using-把-llm-当-调度器" aria-label="Permalink to &quot;6. 工具型（Tool-First / Tool-Using）：把 LLM 当“调度器”&quot;">​</a></h2><p><strong>定义</strong></p><ul><li>重点不在“生成长文本”，而在“选择并正确调用工具”，将确定性工作交给工具完成。</li></ul><p><strong>适用场景</strong></p><ul><li>计算、查询、改文件、调用内部系统、跑脚本/测试等“确定性强”的任务。</li></ul><p><strong>优缺点</strong></p><ul><li>优点：可靠性与效率更高；结果更可验证。</li><li>缺点：工具契约设计成本高；权限与安全要求更高。</li></ul><h2 id="_7-检索增强-rag-first-以-外部知识-为中心" tabindex="-1">7. 检索增强（RAG-First）：以“外部知识”为中心 <a class="header-anchor" href="#_7-检索增强-rag-first-以-外部知识-为中心" aria-label="Permalink to &quot;7. 检索增强（RAG-First）：以“外部知识”为中心&quot;">​</a></h2><p><strong>定义</strong></p><ul><li>主要步骤是检索、过滤、引用、综合，而不是凭模型内置知识回答。</li></ul><p><strong>适用场景</strong></p><ul><li>企业知识库问答、制度/流程查询、产品文档助手、代码库导读等。</li></ul><p><strong>优缺点</strong></p><ul><li>优点：事实性更强，可追溯；更适合私有知识。</li><li>缺点：检索质量决定上限；需要处理权限、过期信息与引用。</li></ul><h2 id="_8-反思-自校验-reflect-critic-verifier-带-质量控制-的-agent" tabindex="-1">8. 反思/自校验（Reflect / Critic / Verifier）：带“质量控制”的 Agent <a class="header-anchor" href="#_8-反思-自校验-reflect-critic-verifier-带-质量控制-的-agent" aria-label="Permalink to &quot;8. 反思/自校验（Reflect / Critic / Verifier）：带“质量控制”的 Agent&quot;">​</a></h2><p><strong>定义</strong></p><ul><li>在关键步骤前后增加校验回路：自检、对抗审查、单元测试、规则校验等。</li></ul><p><strong>适用场景</strong></p><ul><li>需要高准确率或高风险动作：代码改动、财务报表、合规文案、生产操作等。</li></ul><p><strong>优缺点</strong></p><ul><li>优点：显著提升稳定性与可控性；便于把“质量标准”产品化。</li><li>缺点：成本更高，延迟更大；需要定义清晰的验收规则。</li></ul><h2 id="_9-多智能体-multi-agent-分工协作或相互制衡" tabindex="-1">9. 多智能体（Multi-Agent）：分工协作或相互制衡 <a class="header-anchor" href="#_9-多智能体-multi-agent-分工协作或相互制衡" aria-label="Permalink to &quot;9. 多智能体（Multi-Agent）：分工协作或相互制衡&quot;">​</a></h2><p><strong>定义</strong></p><ul><li>将任务拆成多个角色：规划者、执行者、检索者、审核者、谈判者等，通过消息协作完成目标。</li></ul><p><strong>适用场景</strong></p><ul><li>复杂项目、长链路研究、需要不同工具权限隔离的任务。</li></ul><p><strong>优缺点</strong></p><ul><li>优点：更强的分工与并行；能引入对抗减少错误。</li><li>缺点：系统复杂度与成本上升；容易出现“沟通回路”与角色重叠。</li></ul><h2 id="_10-长运行-事件驱动-long-running-event-driven-像服务一样运行" tabindex="-1">10. 长运行/事件驱动（Long-Running / Event-Driven）：像服务一样运行 <a class="header-anchor" href="#_10-长运行-事件驱动-long-running-event-driven-像服务一样运行" aria-label="Permalink to &quot;10. 长运行/事件驱动（Long-Running / Event-Driven）：像服务一样运行&quot;">​</a></h2><p><strong>定义</strong></p><ul><li>Agent 不只是“问一次答一次”，而是持续监听事件（告警、消息、定时任务、队列），并在后台执行动作。</li></ul><p><strong>适用场景</strong></p><ul><li>运维告警处理、工单处理、自动化运营、持续监控与报告等。</li></ul><p><strong>优缺点</strong></p><ul><li>优点：真正进入生产自动化；可积累运行经验与指标。</li><li>缺点：需要完善的可观测、权限、限流、回滚与人工兜底。</li></ul><h2 id="_11-一张快速对比表-怎么选" tabindex="-1">11. 一张快速对比表（怎么选） <a class="header-anchor" href="#_11-一张快速对比表-怎么选" aria-label="Permalink to &quot;11. 一张快速对比表（怎么选）&quot;">​</a></h2><table tabindex="0"><thead><tr><th>类型</th><th>关键词</th><th>最适合</th><th>主要风险</th></tr></thead><tbody><tr><td>反应式（ReAct）</td><td>边做边想</td><td>不确定、探索型任务</td><td>绕路、成本不可控</td></tr><tr><td>规划式（Plan&amp;Execute）</td><td>先计划</td><td>目标清晰、可审计</td><td>计划失真需重规划</td></tr><tr><td>工作流/图</td><td>强约束</td><td>合规流程、可预测任务</td><td>维护成本、灵活性低</td></tr><tr><td>工具型</td><td>调度工具</td><td>计算/查询/执行</td><td>权限与工具契约</td></tr><tr><td>RAG-First</td><td>以检索为主</td><td>私有知识问答</td><td>检索质量与引用</td></tr><tr><td>反思/校验</td><td>质量回路</td><td>高准确率/高风险</td><td>成本与延迟</td></tr><tr><td>多智能体</td><td>分工协作</td><td>复杂任务并行</td><td>系统复杂度</td></tr><tr><td>长运行/事件驱动</td><td>持续服务</td><td>监控/工单/自动化</td><td>治理与兜底</td></tr></tbody></table><h2 id="_12-结论-agent-type-不是-互斥标签-而是-组合配方" tabindex="-1">12. 结论：agent type 不是“互斥标签”，而是“组合配方” <a class="header-anchor" href="#_12-结论-agent-type-不是-互斥标签-而是-组合配方" aria-label="Permalink to &quot;12. 结论：agent type 不是“互斥标签”，而是“组合配方”&quot;">​</a></h2><p>实际系统里，agent type 往往是组合的：</p><ul><li>用 <strong>RAG-First</strong> 提供事实底座</li><li>用 <strong>Reactive（ReAct）</strong> 组织多轮推进</li><li>用 <strong>Tool-First</strong> 执行确定性步骤</li><li>用 <strong>Critic/Verifier</strong> 在关键节点做校验</li><li>在高风险场景外层套一层 <strong>Workflow + HITL</strong></li></ul><p>当你说“ReAct 是一种反应式 agentType”时，核心含义就是：它强调每轮的动作选择与观察反馈的闭环推进，而不是预先固化完整流程。把 agent type 讲清楚，后面你再讨论“核心组件”或“技能（Skills）”时，就能更容易解释这些能力应该如何被组织与运行。</p>`,77),r=[n];function s(o,g,p,d,u,h){return l(),e("div",null,r)}const _=t(i,[["render",s]]);export{b as __pageData,_ as default};
