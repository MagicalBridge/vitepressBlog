import{_ as s,c as i,o as a,aj as n}from"./chunks/framework.K2WCgrB4.js";const g=JSON.parse('{"title":"14.最长公共前缀","description":"","frontmatter":{"sidebar":"auto"},"headers":[],"relativePath":"algorithm/leetcode/14.最长公共前缀.md","filePath":"algorithm/leetcode/14.最长公共前缀.md"}'),l={name:"algorithm/leetcode/14.最长公共前缀.md"},e=n(`<h1 id="_14-最长公共前缀" tabindex="-1">14.最长公共前缀 <a class="header-anchor" href="#_14-最长公共前缀" aria-label="Permalink to &quot;14.最长公共前缀&quot;">​</a></h1><h2 id="题目描述" tabindex="-1"><a href="https://leetcode.cn/problems/longest-common-prefix/description/" target="_blank" rel="noreferrer">题目描述</a> <a class="header-anchor" href="#题目描述" aria-label="Permalink to &quot;[题目描述](https://leetcode.cn/problems/longest-common-prefix/description/)&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>标签: 字符串</p><p>关联企业：虾皮信息、美团、字节跳动、腾讯</p></div><p>编写一个函数来查找字符串数组中的最长公共前缀，如果不存在公共前缀，返回空字符串 &quot;&quot;,</p><p>示例1:</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span></span>
<span class="line"><span>输出：&quot;fl&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>示例2:</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span></span>
<span class="line"><span>输出：&quot;&quot;</span></span>
<span class="line"><span>解释：输入不存在公共前缀.</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="算法思路" tabindex="-1">算法思路： <a class="header-anchor" href="#算法思路" aria-label="Permalink to &quot;算法思路：&quot;">​</a></h2><ul><li>1 首先进行判空处理，因为题目中明确的说明了如果找不到公共前缀则返回空字符串</li><li>2 我们假定第一个数组中的第一个字符串就是公共前缀。</li><li>3 从数组的第二项开始循环，和前缀字符串进行比较，当我们发现，前缀不相同的时候，对前缀进行处理，举个例子，flow 判断 flower 是不是前缀，发现并不是的，截取flower 变成 flowe，接着截取 变成 flow 发现 这个符合，此时公共前缀已经被更新成了 flow。紧着着，开始循环第三个元素，flight 使用startsWith 发现 flow 也不是前缀，继续截取 pre 变成 flo，发现还不是，继续截取 变成 fl，此时满足条件。</li><li>4 条件执行完毕之后，返回 公共前缀。</li></ul><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {string[]}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> strs</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {string}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> longestCommonPrefix</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">strs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (strs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> strs.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pre </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> strs[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> strs.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">strs[i].</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">startsWith</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(pre)) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      pre </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pre.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">substring</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, pre.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pre</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h2 id="复杂度分析" tabindex="-1">复杂度分析 <a class="header-anchor" href="#复杂度分析" aria-label="Permalink to &quot;复杂度分析&quot;">​</a></h2><ol><li><p>时间复杂度分析：</p><ul><li>在最坏情况下，需要比较的字符数量为所有字符串中最短字符串的长度，记为 m。</li><li>假设字符串数组中共有 n 个字符串，那么在每次迭代中，需要比较的字符数量为 1、2、3 直到 m，共有 m 次比较。</li><li>因此，总的比较次数为 n * m。</li><li>所以，时间复杂度为 O(n * m)，其中 n 是字符串数组的长度，m 是所有字符串中最短字符串的长度。</li></ul></li><li><p>空间复杂度分析：</p><ul><li>函数中只使用了几个常量级的变量（<code>pre</code>、<code>i</code>），以及一个 substring 函数的调用栈。</li><li>虽然在每次迭代中都会生成新的子串 <code>pre</code>，但其长度不会超过最短字符串的长度，因此空间复杂度是常数级的，即 O(1)。</li></ul></li></ol><p>综上所述，该函数的时间复杂度为 O(n * m)，空间复杂度为 O(1)。</p>`,14),p=[e];function t(h,r,k,d,o,c){return a(),i("div",null,p)}const u=s(l,[["render",t]]);export{g as __pageData,u as default};
