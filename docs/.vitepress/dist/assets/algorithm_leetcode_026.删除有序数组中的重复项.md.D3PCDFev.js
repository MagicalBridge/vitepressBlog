import{_ as s,c as i,o as a,a4 as n}from"./chunks/framework.CKqHMtmV.js";const g=JSON.parse('{"title":"026.删除有序数组中的重复项","description":"","frontmatter":{"sidebar":"auto"},"headers":[],"relativePath":"algorithm/leetcode/026.删除有序数组中的重复项.md","filePath":"algorithm/leetcode/026.删除有序数组中的重复项.md"}'),l={name:"algorithm/leetcode/026.删除有序数组中的重复项.md"},t=n(`<h1 id="_026-删除有序数组中的重复项" tabindex="-1">026.删除有序数组中的重复项 <a class="header-anchor" href="#_026-删除有序数组中的重复项" aria-label="Permalink to &quot;026.删除有序数组中的重复项&quot;">​</a></h1><h2 id="题目描述" tabindex="-1"><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noreferrer">题目描述</a> <a class="header-anchor" href="#题目描述" aria-label="Permalink to &quot;[题目描述](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>标签：数组、双指针</p></div><h2 id="算法思路" tabindex="-1">算法思路： <a class="header-anchor" href="#算法思路" aria-label="Permalink to &quot;算法思路：&quot;">​</a></h2><p><a href="https://ricepudding.cn/article/94e253b0" target="_blank" rel="noreferrer">详细动图解释</a></p><p>本题可以使用快慢指针的思路求解，题目中已经给了前提条件「数组是有序的」，那么重复的元素一定会相邻；</p><p>初始阶段，slow 和 fast 指向同一个位置，然后可以遵循以下步骤移动指针：</p><ul><li>比较 slow 和 fast 两个指针的位置对应的元素值是否相等； <ul><li>如果相等，则fast指针后移一位；</li><li>如果不相等，此时说明 slow 和 fast 间都是重复的值，此时，fast指针所在的位置的元素是不重复的元素，将 slow 后移一位，将fast位置不重复的元素复制到slow指针所在的位置上，fast指针后移一位继续寻找不同的值。</li></ul></li><li>重复上面的步骤，直到fast等于数组的长度；</li><li>返回slow + 1 即位新数组的长度；</li></ul><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * 给定一个已排序的数组 nums，原地删除重复出现的元素，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * 使每个元素只出现一次，返回新的数组长度。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> - 含有重复元素的已排序数组。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@returns</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> 删除重复元素后数组的新长度。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> removeDuplicates</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">nums</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[])</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 初始化两个指针，slow 和 fast，均指向数组的起始位置。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> slow</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fast</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 使用 fast 指针遍历数组。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (fast </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 判断 fast 指针所指元素是否与 slow 指针所指元素相同。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (nums[fast] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums[slow]) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 若不同，将 slow 指针右移一位，并将 slow 指针所在位置的元素更新为 fast 指针所指元素。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      slow</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      nums[slow] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums[fast];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 移动 fast 指针到下一个位置。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fast</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // slow 指针现在表示修改后数组的最后一个唯一元素。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 返回数组的新长度（slow + 1）。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> slow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在这个算法中，slow 指针表示修改后数组中的最后一个唯一元素的索引，由于数组的索引是从0开始的，所以slow指针的值实际上是数组中唯一元素的数量减去1，</p><p>当 slow 指针移动到数组的最后一个唯一元素时，整个数组中唯一元素的数量即为 slow + 1。因此，为了符合问题的要求，函数需要返回修改后数组的新长度，即 slow + 1。</p><p>举例说明：</p><p>假设数组 nums 为 [1, 1, 2, 2, 3]，在经过 removeDuplicates 函数操作后，数组变为 [1, 2, 3]，而 slow 指针停留在索引 2 处（最后一个唯一元素的索引）。此时，唯一元素的数量为 slow + 1 = 3，因此函数返回 3，表示修改后数组的新长度。</p><h2 id="复杂度分析" tabindex="-1">复杂度分析 <a class="header-anchor" href="#复杂度分析" aria-label="Permalink to &quot;复杂度分析&quot;">​</a></h2><p>时间复杂度分析：O(n) 其中 n 是数组的长度。原因如下：</p><ul><li>算法使用双指针，其中 <code>fast</code> 指针从头到尾遍历整个数组，而 <code>slow</code> 指针仅在发现新元素时移动。</li><li>每个元素只会被访问一次，因此遍历的总时间复杂度为 O(n)。</li></ul><p>空间复杂度分析：该算法的空间复杂度是 O(1)。原因如下：</p><ul><li>算法只使用了常数级别的额外空间，即两个指针（<code>slow</code> 和 <code>fast</code>）和常数个辅助变量。</li><li>不随着输入规模的增加而增加额外的空间。</li></ul>`,18),h=[t];function p(e,k,r,d,o,E){return a(),i("div",null,h)}const y=s(l,[["render",p]]);export{g as __pageData,y as default};
