import{_ as e,c as o,o as t,aj as i}from"./chunks/framework.K2WCgrB4.js";const h=JSON.parse('{"title":"Vue3对比Vue2的变化","description":"","frontmatter":{"sidebar":"auto"},"headers":[],"relativePath":"vue/vue3/03.reactivity-1.md","filePath":"vue/vue3/03.reactivity-1.md"}'),a={name:"vue/vue3/03.reactivity-1.md"},c=i('<h1 id="vue3对比vue2的变化" tabindex="-1">Vue3对比Vue2的变化 <a class="header-anchor" href="#vue3对比vue2的变化" aria-label="Permalink to &quot;Vue3对比Vue2的变化&quot;">​</a></h1><ul><li>在Vue2的时候使用defineProperty来进行数据的劫持, 需要对属性进行重写添加<code>getter</code>及<code>setter</code>性能相对比较差。</li><li>当新增属性和删除属性时无法监控变化。需要通过 <code>$set</code>、<code>$delete</code>实现;</li><li>数组不采用defineProperty来进行劫持 （浪费性能，对所有索引进行劫持会造成性能浪费）需要对数组单独进行处理</li></ul><blockquote><p>Vue3中使用Proxy来实现响应式数据变化。从而解决了上述问题。</p></blockquote><h1 id="compositionapi" tabindex="-1">CompositionAPI <a class="header-anchor" href="#compositionapi" aria-label="Permalink to &quot;CompositionAPI&quot;">​</a></h1><ul><li>在Vue2中采用的是OptionsAPI, 用户提供的data,props,methods,computed,watch等属性 (用户编写复杂业务逻辑会出现反复横跳问题)</li><li>Vue2中所有的属性都是通过<code>this</code>访问，<code>this</code>存在指向明确问题</li><li>Vue2中很多未使用方法或属性依旧会被打包，并且所有全局API都在Vue对象上公开.Composition API对 tree-shaking 更加友好，代码也更容易压缩。</li><li>组件逻辑共享问题， Vue2 采用mixins 实现组件之间的逻辑共享； 但是会有数据来源不明确，命名冲突等问题。 Vue3采用CompositionAPI 提取公共逻辑非常方便;</li></ul><blockquote><p>简单的组件仍然可以采用optionsAPI进行编写，compositionAPI在复杂的逻辑中有着明显的优势~。 <code>reactivity</code>模块中就包含了很多我们经常使用到的<code>API</code> 例如：computed、reactive、ref、effect等;</p></blockquote>',6),r=[c];function u(d,s,l,n,p,_){return t(),o("div",null,r)}const v=e(a,[["render",u]]);export{h as __pageData,v as default};
