import{_ as e,c as o,o as c,aj as l}from"./chunks/framework.K2WCgrB4.js";const a="/vitepressBlog/assets/05.y8qq0yga.png",h=JSON.parse('{"title":"深入理解Webpack配置的底层逻辑","description":"","frontmatter":{"sidebar":"auto"},"headers":[],"relativePath":"front-end-engineering/webpack/webpack-config.md","filePath":"front-end-engineering/webpack/webpack-config.md"}'),i={name:"front-end-engineering/webpack/webpack-config.md"},t=l('<h1 id="深入理解webpack配置的底层逻辑" tabindex="-1">深入理解Webpack配置的底层逻辑 <a class="header-anchor" href="#深入理解webpack配置的底层逻辑" aria-label="Permalink to &quot;深入理解Webpack配置的底层逻辑&quot;">​</a></h1><p>Webpack5提供了非常强大、灵活的模块打包功能，配合其成熟生态下数量庞大的插件、Loader资源，已经能够满足大多数前端项目的工程化需求，但代价则是日益复杂、晦涩的使用方法，开发者通常需要根据项目环境、资源类型、编译目标编写一份复杂的配置文件，用以定制资源打包行为。</p><p>问题是，仅 Webpack 原生配置项就多达上百种，且各项之间缺乏一致性与关联度，对初学者而言单是掌握每一个配置的作用与变种就已经很难，更不用说理解配置与配置之间的协作关系。</p><p>对此，这里将尝试通过一种结构化视角分类讨论 Webpack 各个核心配置项的功能与作用；再用一个简单的例子介绍配置项结构的逻辑；最后介绍一些业界比较知名，能迅速生成项目脚手架的工具。</p><h2 id="结构化理解-webpack-配置项" tabindex="-1">结构化理解 Webpack 配置项 <a class="header-anchor" href="#结构化理解-webpack-配置项" aria-label="Permalink to &quot;结构化理解 Webpack 配置项&quot;">​</a></h2><p>Webpack 原生提供了上百种配置项，这些配置最终都会作用于 Webpack 打包过程的不同阶段，因此我们可以从流程角度更框架性、结构化地了解各项配置的作用。</p><p>Webpack 的打包过程非常复杂，但大致上可简化为：</p><blockquote><p>输入 -&gt; 模块处理 -&gt; 后处理 -&gt; 输出</p></blockquote><ul><li><strong>输入</strong>：从文件系统读入代码文件；</li><li><strong>模块递归处理</strong>：调用 Loader 转译 Module 内容，并将结果转换为AST，从中分析出模块依赖关系，进一步递归调用模块处理过程，直到所有依赖文件都处理完毕；</li><li><strong>后处理</strong>：所有模块递归处理完毕后开始执行后处理，包括模块合并、注入运行时、产物优化等，最终输出 Chunk 集合；</li><li><strong>输出</strong>：将 Chunk 写出到外部文件系统；</li></ul><p>从上述打包流程角度，Webpack 配置项大体上可分为两类：</p><ul><li><strong>流程类</strong>：作用于打包流程某个或若干个环节，直接影响编译打包效果的配置项</li><li><strong>工具类</strong>：打包主流程之外，提供更多工程化工具的配置项</li></ul><h3 id="流程类的配置概述" tabindex="-1">流程类的配置概述： <a class="header-anchor" href="#流程类的配置概述" aria-label="Permalink to &quot;流程类的配置概述：&quot;">​</a></h3><p>与打包流程强相关的配置项有：</p><ul><li>输入输出： <ul><li><code>entry</code>: 用于定义项目入口文件，Webpack 会从这些入口文件开始按图索骥找出所有项目文件；</li><li><code>context</code>: 项目执行上下文路径；</li><li><code>output</code>: 配置产物的输出路径、名称等；</li></ul></li><li>模块处理： <ul><li><code>resolve</code>: 用于配置模块路径解析规则，可用于帮助 Webpack 更精确、高效地找到指定模块</li><li><code>module</code>: 用于配置模块加载规则，例如针对什么类型的资源需要使用哪些 Loader 进行处理</li><li><code>externals</code>: 用于声明外部资源，Webpack 会直接忽略这部分资源，跳过这些资源的解析、打包操作</li></ul></li><li>后处理： <ul><li><code>optimization</code>: 用于控制如何优化产物包体积，内置 Dead Code Elimination、Scope Hoisting、代码混淆、代码压缩等功能;</li><li><code>target</code>: 用于配置编译产物的目标运行环境，支持 web、node、electron 等值，不同值最终产物会有所差异;</li><li><code>mode</code>: 编译模式短语，支持 development、production 等值，可以理解为一种声明环境的短语</li></ul></li></ul><p>这里的重点是，Webpack 首先需要根据输入配置(<code>entry/context</code>) 找到项目入口文件；之后根据按模块处理(<code>module/resolve/externals</code>等) 所配置的规则逐一处理模块文件，处理过程包括转译、依赖分析等；模块处理完毕后，最后再根据后处理相关配置项(<code>optimization/target</code> 等)合并模块资源、注入运行时依赖、优化产物结构等。</p><p>这些配置项与打包流程强相关，使用的时候需要多关注它们对主流程的影响，例如<code>entry</code>决定了项目入口，而<code>output</code>则决定产物最终往哪里输出；<code>resolve</code>决定了怎么找到模块，而<code>module</code> 决定了如何解读模块内容，等等。。。。。。</p><h3 id="工具配置项综述" tabindex="-1">工具配置项综述： <a class="header-anchor" href="#工具配置项综述" aria-label="Permalink to &quot;工具配置项综述：&quot;">​</a></h3><p>除了核心的打包功能之外，Webpack 还提供了一系列用于提升研发效率的工具，大体上可划分为：</p><ul><li>开发效率类： <ul><li><code>watch</code>：用于配置持续监听文件变化，持续构建</li><li><code>devtool</code>：用于配置产物 Sourcemap 生成规则</li><li><code>devServer</code>：用于配置与 HMR 强相关的开发服务器功能</li></ul></li><li>性能优化类： <ul><li><code>cache</code>：Webpack5之后，该项用于控制如何缓存编译过程信息与编译结果</li><li><code>performance</code>：用于配置当产物大小超过阈值时，如何通知开发者</li></ul></li><li>日志类： <ul><li><code>stats</code>：用于精确地控制编译过程的日志内容，在做比较细致的性能调试时非常有用</li><li><code>infrastructureLogging</code>：用于控制日志输出方式，例如可以通过该配置将日志输出到磁盘文件</li></ul></li></ul><p>逻辑上，每一个工具类配置都在主流程之外提供额外的工程化能力，例如<code>devtool</code>用于配置产物 Sourcemap 生成规则，与 Sourcemap 强相关；<code>devServer</code> 用于配置与 HMR 相关的开发服务器功能；<code>watch</code> 用于实现持续监听、构建。</p><p>工具类配置内聚性较强，通常一个配置项专注于解决一类工程问题，学习时建议先对配置项按其功能做个简单分类，例如上述开发效率类、性能优化类等，之后再展开研究其可选值与效果。</p><p><img src="'+a+'" alt="流程配置分类"></p>',22),d=[t];function r(n,p,s,u,b,k){return c(),o("div",null,d)}const _=e(i,[["render",r]]);export{h as __pageData,_ as default};
