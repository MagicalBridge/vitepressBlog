import{_ as a,c as e,o as n,aj as t}from"./chunks/framework.K2WCgrB4.js";const _=JSON.parse('{"title":"Agent 智能体：把“大模型会说”变成“系统能做”","description":"","frontmatter":{},"headers":[],"relativePath":"ai/agent/01.agent的基本概念.md","filePath":"ai/agent/01.agent的基本概念.md"}'),s={name:"ai/agent/01.agent的基本概念.md"},i=t(`<h1 id="agent-智能体-把-大模型会说-变成-系统能做" tabindex="-1">Agent 智能体：把“大模型会说”变成“系统能做” <a class="header-anchor" href="#agent-智能体-把-大模型会说-变成-系统能做" aria-label="Permalink to &quot;Agent 智能体：把“大模型会说”变成“系统能做”&quot;">​</a></h1><p>Agent（智能体）不是某个特定模型或框架，而是一类系统形态：它以目标为中心，能在多轮过程中组织信息、做出决策、调用工具执行动作，并根据结果继续推进任务。你可以把 LLM 看作“脑”，而 Agent 是“脑 + 手脚 + 运行机制”的组合。</p><h2 id="_1-什么是-agent" tabindex="-1">1. 什么是 Agent <a class="header-anchor" href="#_1-什么是-agent" aria-label="Permalink to &quot;1. 什么是 Agent&quot;">​</a></h2><p>从工程角度，一个系统要称得上 Agent，通常具备三个要素：</p><ul><li><strong>目标导向</strong>：输入不是单纯聊天话题，而是要完成的任务与约束（时限、权限、成本、格式）。</li><li><strong>可执行</strong>：能把决策落到行动上（调用工具/API、读写数据、触发流程），而不仅是生成文本。</li><li><strong>可持续</strong>：能跨多轮维护状态（进度、已知事实、失败原因），根据观察结果调整下一步。</li></ul><h2 id="_2-为什么-llm-时代-agent-再次成为主角" tabindex="-1">2. 为什么 LLM 时代 Agent 再次成为主角 <a class="header-anchor" href="#_2-为什么-llm-时代-agent-再次成为主角" aria-label="Permalink to &quot;2. 为什么 LLM 时代 Agent 再次成为主角&quot;">​</a></h2><p>传统软件 Agent 依赖规则、规划算法或强化学习，在开放域的语言理解与泛化能力上成本很高。LLM 出现后，Agent 形态的门槛被明显降低：</p><ul><li><strong>语言理解与推理能力</strong>让“用自然语言描述任务”变得可行</li><li><strong>结构化输出/函数调用能力</strong>让“把意图对接到工具”更稳定</li><li><strong>文本生成能力</strong>让“过程解释、总结汇报、对话交互”天然具备</li></ul><p>但要强调的是：LLM 解决的是“认知与表达”，Agent 还需要“执行与控制面”。否则系统仍然停留在“会回答但不会办事”。</p><h2 id="_3-agent-的典型工作方式-一个闭环" tabindex="-1">3. Agent 的典型工作方式：一个闭环 <a class="header-anchor" href="#_3-agent-的典型工作方式-一个闭环" aria-label="Permalink to &quot;3. Agent 的典型工作方式：一个闭环&quot;">​</a></h2><p>Agent 的核心不是某个模块名字，而是闭环运行：每一轮都在决定“下一步做什么”，并用结果更新状态。</p><div class="language-mermaid vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">flowchart LR</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  U[目标/输入] --&gt; C[上下文构建]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  C --&gt; D[决策: 回复/调用工具/等待]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  D --&gt; X[执行器]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  X --&gt; O[观察结果]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  O --&gt; M[状态/记忆更新]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  M --&gt; C</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这个循环解释了为什么 Agent 必须具备工具、状态与执行器：缺任一环，就很难稳定完成多步骤任务。</p><h2 id="_4-agent-与-llm-或聊天机器人-的区别" tabindex="-1">4. Agent 与 LLM（或聊天机器人）的区别 <a class="header-anchor" href="#_4-agent-与-llm-或聊天机器人-的区别" aria-label="Permalink to &quot;4. Agent 与 LLM（或聊天机器人）的区别&quot;">​</a></h2><p>很多“看起来像 Agent”的产品，实际上只是一个带对话历史的聊天机器人。可以用四个维度做区分：</p><h3 id="_4-1-输入形态" tabindex="-1">4.1 输入形态 <a class="header-anchor" href="#_4-1-输入形态" aria-label="Permalink to &quot;4.1 输入形态&quot;">​</a></h3><ul><li><strong>LLM/聊天机器人</strong>：以问答为主，输入多是“请解释/请写一段”</li><li><strong>Agent</strong>：以任务为主，输入通常包含目标、约束、资源与验收标准</li></ul><h3 id="_4-2-行为能力" tabindex="-1">4.2 行为能力 <a class="header-anchor" href="#_4-2-行为能力" aria-label="Permalink to &quot;4.2 行为能力&quot;">​</a></h3><ul><li><strong>LLM/聊天机器人</strong>：主要输出文本</li><li><strong>Agent</strong>：能选择动作并执行（工具调用、检索、改文件、发请求、触发流程）</li></ul><h3 id="_4-3-运行方式" tabindex="-1">4.3 运行方式 <a class="header-anchor" href="#_4-3-运行方式" aria-label="Permalink to &quot;4.3 运行方式&quot;">​</a></h3><ul><li><strong>LLM/聊天机器人</strong>：被动响应，每轮相对独立</li><li><strong>Agent</strong>：持续推进，多轮自我纠错，必要时拆分子任务</li></ul><h3 id="_4-4-可控性与可观测性" tabindex="-1">4.4 可控性与可观测性 <a class="header-anchor" href="#_4-4-可控性与可观测性" aria-label="Permalink to &quot;4.4 可控性与可观测性&quot;">​</a></h3><ul><li><strong>LLM/聊天机器人</strong>：难追踪“为什么这么答”</li><li><strong>Agent</strong>：应当可回放每轮输入、工具调用、结果与状态变化，便于评估与治理</li></ul><p>用一句话概括：</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Agent = LLM + 工具（行动）+ 状态（持续）+ 策略（决策）+ 执行（控制）</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="_5-常见的-agent-形态-从简单到复杂" tabindex="-1">5. 常见的 Agent 形态（从简单到复杂） <a class="header-anchor" href="#_5-常见的-agent-形态-从简单到复杂" aria-label="Permalink to &quot;5. 常见的 Agent 形态（从简单到复杂）&quot;">​</a></h2><h3 id="_5-1-工具增强问答-最轻量" tabindex="-1">5.1 工具增强问答（最轻量） <a class="header-anchor" href="#_5-1-工具增强问答-最轻量" aria-label="Permalink to &quot;5.1 工具增强问答（最轻量）&quot;">​</a></h3><p>主要是“先检索/查询，再回答”，通常不需要长流程，但需要工具与上下文构建。适合知识问答、客服检索、内部文档助手。</p><h3 id="_5-2-迭代执行型-多步任务" tabindex="-1">5.2 迭代执行型（多步任务） <a class="header-anchor" href="#_5-2-迭代执行型-多步任务" aria-label="Permalink to &quot;5.2 迭代执行型（多步任务）&quot;">​</a></h3><p>每轮决定下一步行动，直到完成目标或遇到不可恢复失败。适合数据分析、自动化办公、排障等。</p><h3 id="_5-3-工作流-图编排型-强约束" tabindex="-1">5.3 工作流/图编排型（强约束） <a class="header-anchor" href="#_5-3-工作流-图编排型-强约束" aria-label="Permalink to &quot;5.3 工作流/图编排型（强约束）&quot;">​</a></h3><p>用固定节点和分支把流程固化，LLM 只在少数节点做决策或填参。适合合规要求高、流程确定、可审计场景。</p><h3 id="_5-4-多智能体协作-分工与对抗" tabindex="-1">5.4 多智能体协作（分工与对抗） <a class="header-anchor" href="#_5-4-多智能体协作-分工与对抗" aria-label="Permalink to &quot;5.4 多智能体协作（分工与对抗）&quot;">​</a></h3><p>把复杂任务拆给多个角色（规划者、执行者、审核者、检索者等），通过消息协作完成。适合大型项目、长链路任务，但复杂度与成本也更高。</p><h2 id="_6-什么时候应该用-agent" tabindex="-1">6. 什么时候应该用 Agent <a class="header-anchor" href="#_6-什么时候应该用-agent" aria-label="Permalink to &quot;6. 什么时候应该用 Agent&quot;">​</a></h2><p>一个实用判断：如果你的问题满足以下任意两条，通常就值得用 Agent 思路来做系统化设计：</p><ul><li>任务需要<strong>多步骤</strong>推进，且每一步依赖上一步的结果</li><li>需要<strong>外部动作</strong>（工具/API/系统操作），而不是只生成一段文字</li><li>需要<strong>可恢复与可追踪</strong>（中断续跑、失败重试、过程审计）</li><li>需要<strong>可靠性与治理</strong>（权限、确认、风控、评估）</li></ul><p>如果只是单轮写作、翻译、润色，LLM 即可；过早引入 Agent 反而会带来成本与不确定性。</p><h2 id="_7-小结与下一篇" tabindex="-1">7. 小结与下一篇 <a class="header-anchor" href="#_7-小结与下一篇" aria-label="Permalink to &quot;7. 小结与下一篇&quot;">​</a></h2><p>Agent 是“面向任务的闭环系统”，LLM 只是其中的大脑。真正决定能不能落地的，往往是工具契约、状态管理、执行控制与可观测性。</p><p>下一篇会把“核心组件”按工程视角逐一展开：<a href="./02.agent的核心组件.html">02.agent的核心组件</a>。</p>`,41),l=[i];function r(o,h,g,p,d,c){return n(),e("div",null,l)}const b=a(s,[["render",r]]);export{_ as __pageData,b as default};
