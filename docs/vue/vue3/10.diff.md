---
sidebar: auto
---

# Diff核心流程和原理

## 前后元素不一致

两个不同的虚拟节点不需要进行比较，直接移除老的节点，将新的虚拟节点渲染成真实的DOM进行挂载即可。

```js
// 判断两个虚拟节点的类型是不是一样
export const isSameVNodeType = (n1, n2) => {
  return n1.type === n2.type && n1.key === n2.key;
}

const patch = (n1,n2,container) => {
  // 初始化和diff算法都在这里喲
  if(n1 == n2){ return }
  if(n1 && !isSameVNodeType(n1,n2)){ // 有n1是n1和n2不是同一个节点
    unmount(n1)
    n1 = null
  }
  if (n1 == null) { // 初始化的情况
    mountElement(n2, container); 
  } else {
    // diff算法
  }
}
```
从上面的实现细节可以看出，如果两个虚拟节点相同，则不需要进行比对，直接返回即可，如果前后两个虚拟节点类型都不一样，根本无需比对，直接卸载掉上一个节点，将上一个节点重置为null,直接渲染新的节点即可。初始化的场景中，上一个节点确实为null，直接渲染即可。

所以diff的重点实际上是在元素节点是相同的，但是上面的属性不同，或者它的孩子发生了变化。

## 前后元素一致

前后元素一致则比较两个元素的属性和孩子节点，这个上面我们已经分析了出来。

```js
const patchElement = (n1, n2) => {
  let el = (n2.el = n1.el);
  const oldProps = n1.props || {};
  const newProps = n2.props || {};
  patchProps(oldProps, newProps, el); // 比对新老属性
  patchChildren(n1, n2, el); // 比较元素的孩子节点
}

const processElement = (n1, n2, container) => {
  if (n1 == null) {
    mountElement(n2, container)
  } else {
    patchElement(n1, n2); // 比较两个元素
  }
}
```

总结下来，差异的场景主要有八种:

| 新节点儿子 | 旧节点儿子| 操作方式 |
|-----------|-----------| -------|
|文本	|数组	|（删除老儿子，设置文本内容）|
|文本	|文本	|（更新文本即可）|
|文本	|空	|（更新文本即可) 与上面的类似|
|数组	|数组|	（diff算法）|
|数组	|文本|	（清空文本，进行挂载）|
|数组	|空	|（进行挂载） 与上面的类似|
|空	  |数组	|（删除所有儿子）|
|空	  |文本	|（清空文本）|
|空	  |空	|（无需处理）|