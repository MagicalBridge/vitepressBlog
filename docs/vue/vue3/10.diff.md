---
sidebar: auto
---

# Diff核心流程和原理

## 前后元素不一致

两个不同的虚拟节点不需要进行比较，直接移除老的节点，将新的虚拟节点渲染成真实的DOM进行挂载即可。

```js
// 判断两个虚拟节点的类型是不是一样
export const isSameVNodeType = (n1, n2) => {
  return n1.type === n2.type && n1.key === n2.key;
}

const patch = (n1,n2,container) => {
  // 初始化和diff算法都在这里喲
  if(n1 == n2){ return }
  if(n1 && !isSameVNodeType(n1,n2)){ // 有n1是n1和n2不是同一个节点
    unmount(n1)
    n1 = null
  }
  if (n1 == null) { // 初始化的情况
    mountElement(n2, container); 
  } else {
    // diff算法
  }
}
```
从上面的实现细节可以看出，如果两个虚拟节点相同，则不需要进行比对，直接返回即可，如果前后两个虚拟节点类型都不一样，根本无需比对，直接卸载掉上一个节点，将上一个节点重置为null,直接渲染新的节点即可。初始化的场景中，上一个节点确实为null，直接渲染即可。

所以diff的重点实际上是在元素节点是相同的，但是上面的属性不同，或者它的孩子发生了变化。

## 前后元素一致

前后元素一致则比较两个元素的属性和孩子节点，这个上面我们已经分析了出来。

```js
const patchElement = (n1, n2) => {
  let el = (n2.el = n1.el);
  const oldProps = n1.props || {};
  const newProps = n2.props || {};
  patchProps(oldProps, newProps, el); // 比对新老属性
  patchChildren(n1, n2, el); // 比较元素的孩子节点
}

const processElement = (n1, n2, container) => {
  if (n1 == null) {
    mountElement(n2, container)
  } else {
    patchElement(n1, n2); // 比较两个元素
  }
}
```

总结下来，差异的场景主要有八种:

| 新节点儿子 | 旧节点儿子| 操作方式 |
|-----------|-----------| -------|
|文本	|数组	|（删除老儿子，设置文本内容）|
|文本	|文本	|（更新文本即可）|
|文本	|空	|（更新文本即可) 与上面的类似|
|数组	|数组|	（diff算法）|
|数组	|文本|	（清空文本，进行挂载）|
|数组	|空	|（进行挂载） 与上面的类似|
|空	  |数组	|（删除所有儿子）|
|空	  |文本	|（清空文本）|
|空	  |空	|（无需处理）|

```js
const unmountChildren = (children) => {
  for(let i = 0 ; i < children.length; i++) {
    unmount(children[i]);
  }
}

const patchChildren = (n1,n2,el) => {
  const c1 = n1 && n1.children
  const c2 = n2.children
  const prevShapeFlag = n1.shapeFlag;
  const shapeFlag = n2.shapeFlag;
  
  // 当前的是文本，老的可能是 文本、空、数组
  if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {
    if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) { // 老的是数组，直接移除老的节点
      unmountChildren(c1);
    }
    // 当前的是文本，老的可能是 文本、空
    // 只需要判断前后是否一致，不一致直接用新的覆盖
    if (c1 !== c2){ 
      hostSetElementText(el,c2);
    }
  } else {
    // 老的是数组
    if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {
      if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) { // 新的是数组
      // TODO 核心diff算法
      } else {
        // 新的是空，直接将老的移除就可以了
        unmountChildren(c1);
      }
    } else {
      // 老的是文本 新的是空
      if (prevShapeFlag & ShapeFlags.TEXT_CHILDREN) {
        hostSetElementText(el,'');
      }
      // 老的为空 新的是数组
      if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
        mountChildren(c2, el);
      }
    }
  }
}
```

从上面的代码实现细节可以看出，会将两个虚拟节点的类型拿出来比较，以新的节点作为基准，上面列的表格中已经显示出来总共需要处理9种场景：
- 在新的节点是文本的条件下：
  - 如果老的节点孩子是数组，则将老的节点孩子直接卸载移除就可以了。
  - 如果老的节点孩子是文本或者空，直接判断是否相同，不相同直接覆盖就好。

- 新的节点是数组或者空的条件下：
  - 老的节点孩子是数组的条件下：
    - 新的节点的孩子也是数组的条件下：
      - 需要核心的diff的比较
    - 新的节点孩子不是数组
      - 直接卸载老的孩子节点
  - 老的孩子节点不是数组
    - 老的孩子节点是文本类型
      - 设置节点元素为空
    - 新的节点孩子类型为数组
      - 直接设置新的孩子节点

## 核心Diff算法
