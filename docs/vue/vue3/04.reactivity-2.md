---
sidebar: auto
---

# Reactivity模块基本使用
```html
<div id="app"></div>
<script src="./reactivity.global.js"></script>
<script>
  const { 
    reactive, 
    effect, 
    shallowReactive, 
    shallowReadonly, 
    readonly 
  } = VueReactivity;
  // let state = reactive({ name: 'jw', age: 30 });
  // const state = shallowReactive({ name: 'jw', age: 30 })
  // const state = readonly({ name: 'jw', age: 30 })
  const state = reactive({ name: 'jw', age: 30})
  
  effect(() => { // 副作用函数 (effect执行渲染了页面)
    app.innerHTML = state.name + '今年' + state.age + '岁了'
  });

  setTimeout(() => {
    state.age++;
  }, 1000)
</script>
```

> `reactive` 方法会将对象变成`proxy对象`， `effect`中使用`reactive`对象时会进行依赖收集，稍后属性变化时会重新执行`effect`函数。

effect这个函数是vue3中的响应式的核心，computed和watch都是基于它来实现的。这里所说的依赖收集指的是数据会记录自己在哪个effect中被使用了，当数据变化的时候，会通知effect函数重新执行，从而达到数据更新的目的。


## reactive 函数实现
```js
import { isObject } from "@vue/shared"

function createReactiveObject(target, isReadonly) {
  if (!isObject(target)) {
    return target
  }
}
// 常用的就是reactive方法
export function reactive(target) {
  return createReactiveObject(target, false)
}
// 后面的方法，不是重点,我们先不进行实现... 
/*
export function shallowReactive(target: object) {
  return createReactiveObject(target, false)
}
export function readonly(target: object) {
  return createReactiveObject(target, true)
}
export function shallowReadonly(target: object) {
  return createReactiveObject(target, true)
}
*/
```

```javascript
export function isObject(value) {
  return typeof value === 'object' && value !== null
}
```

从上面的代码逻辑来看，reactive 这个函数只会处理对象类型的数据，不是对象类型的数据直接返回。

```js
const reactiveMap = new WeakMap(); // 缓存列表

const mutableHandlers: ProxyHandler<object> = {
  get(target, key, receiver) {
    // 等会谁来取值就做依赖收集
    const res = Reflect.get(target, key, receiver);
    return res;
  },
  set(target, key, value, receiver) {
    // 等会赋值的时候可以重新触发effect执行
    const result = Reflect.set(target, key, value, receiver);
    return result;
  }
}

function createReactiveObject(target: object, isReadonly: boolean) {
  if (!isObject(target)) {
    return target
  }
  const exisitingProxy = reactiveMap.get(target); // 如果已经代理过则直接返回代理后的对象 
  if (exisitingProxy) {
    return exisitingProxy;
  }
  const proxy = new Proxy(target, mutableHandlers); // 对对象进行代理
  reactiveMap.set(target,proxy)
  return proxy;
}
```
从上面的代码可以看出，将代理的处理封装成了一个对象 `mutableHandlers`,在触发get方法的时候进行依赖升级，在触发set方法的时候，进行依赖更新。

### 关于Reflect操作说明

我们看到上面代码的实现中，无论是get函数还是set函数，都没有直接返回`target[key]`,而是使用 `Reflect.get(target, key, receiver)` 和 `Reflect.set(target, key, value, receiver)`

这么做的原因是保证this的指向

```js
let school = {
  name:'zf',
  get num(){
    return this.name;
  }
}
let p = new Proxy(school,{
  get(target, key,receiver){
    console.log(key);
    // return Reflect.get(target,key,receiver)
    return target[key]
  }
})
p.num
```

上面的代码，如果我们直接返回`target[key]`, this指向的是 school 而不是代理对象p,这点要格外注意，如果使用 `Reflect.get(target,key,receiver)` 就能解决这个问题。

### 已经被代理过的对象不需要重复代理

实际的业务场景中，我们代理一个对象让它成为响应式的，有一种场景是: **一个对象被代理过了，我们不希望进行重复代理。**，我们思考如何解决这个问题。其实思路非常巧妙，就是利用代理对象的特性，只要触发取值操作就能够被拦截，这个时候，我们就能发现它是一个代理对象，返回一个true就好了。

```js
const enum ReactiveFlags {
  IS_REACTIVE = '__v_isReactive'
}
const mutableHandlers: ProxyHandler<object> = {
  get(target, key, receiver) {
    if(key === ReactiveFlags.IS_REACTIVE){ // 在get中增加标识，当获取IS_REACTIVE时返回true
      return true;
    }
  }
}
function createReactiveObject(target: object, isReadonly: boolean) {
  ...
  if(target[ReactiveFlags.IS_REACTIVE]){ // 在创建响应式对象时先进行取值，看是否已经是响应式对象
    return target
  }
  ...
}
```

上面代码中，我们声明了一个枚举，普通对象第一次经过 `createReactiveObject` 函数的处理，取不到这个枚举的值，会走代理的逻辑，但是当代理的对象在此经过`createReactiveObject`这个函数的时候，就会触发get方法，判断是不是做了取值操作，如果是说明是已经代理过的对象，直接返回true就好。

## 编写effect函数


