---
sidebar: auto
---

# Reactivity模块基本使用
```html
<div id="app"></div>
<script src="./reactivity.global.js"></script>
<script>
  const { 
    reactive, 
    effect, 
    shallowReactive, 
    shallowReadonly, 
    readonly 
  } = VueReactivity;
  // let state = reactive({ name: 'jw', age: 30 });
  // const state = shallowReactive({ name: 'jw', age: 30 })
  // const state = readonly({ name: 'jw', age: 30 })
  const state = reactive({ name: 'jw', age: 30})
  
  effect(() => { // 副作用函数 (effect执行渲染了页面)
    app.innerHTML = state.name + '今年' + state.age + '岁了'
  });

  setTimeout(() => {
    state.age++;
  }, 1000)
</script>
```

> `reactive` 方法会将对象变成`proxy对象`， `effect`中使用`reactive`对象时会进行依赖收集，稍后属性变化时会重新执行`effect`函数。

effect这个函数是vue3中的响应式的核心，computed和watch都是基于它来实现的。这里所说的依赖收集指的是数据会记录自己在哪个effect中被使用了，当数据变化的时候，会通知effect函数重新执行，从而达到数据更新的目的。


## reactive 函数实现
```js
import { isObject } from "@vue/shared"

function createReactiveObject(target, isReadonly) {
  if (!isObject(target)) {
    return target
  }
}
// 常用的就是reactive方法
export function reactive(target) {
  return createReactiveObject(target, false)
}
// 后面的方法，不是重点,我们先不进行实现... 
/*
export function shallowReactive(target: object) {
  return createReactiveObject(target, false)
}
export function readonly(target: object) {
  return createReactiveObject(target, true)
}
export function shallowReadonly(target: object) {
  return createReactiveObject(target, true)
}
*/
```

```javascript
export function isObject(value) {
  return typeof value === 'object' && value !== null
}
```

从上面的代码逻辑来看，reactive 这个函数只会处理对象类型的数据，不是对象类型的数据直接返回。
