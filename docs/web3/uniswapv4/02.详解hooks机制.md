## 一、Hooks 机制详解：把 AMM 变成“可编程池”

在 [01.基本介绍](file:///Users/chupengfei/code/blog/vitepressBlog/docs/web3/uniswapv4/01.基本介绍.md) 里我们说过：v4 的核心是把 AMM 内核做成平台，然后把“差异化功能”外包给 Hook 合约。

这一篇会把 Hooks 讲透到“能动手写”的程度：生命周期、权限/地址位、数据流、以及几个典型 Hook 的代码骨架。

---

## 二、一个 Hook 到底绑定在哪里？

在 v4 里，**Hook 不是全局的，也不是 Router 上的插件**，而是写进某个 Pool 的 `PoolKey` 里（可以理解为“池子的配置项之一”）。

几个重要结论：

- **一个 Pool 最多绑定一个 Hook 合约地址**（也可以是 0 地址表示无 Hook）
- **Hook 一旦跟 Pool 绑定就不可更换**
- **一个 Hook 合约可以服务很多个 Pool**（在 Hook 内部通常用 `poolId` 做映射存状态）

从心智模型上看：

```
用户/路由器/头寸管理器
        |
        v
   PoolManager（Singleton）
        |
        v
   Hook（可选，可编程逻辑）
```

---

## 三、Hooks 会在什么时候被调用？（生命周期总览）

官方把 Hook 拆成几类：初始化、加减流动性、Swap、Donate（捐赠）。每类都有 before/after 两个切点（有些场景还会带“返回 delta”能力）。

一个简化的时间线如下：

```
initialize
  -> beforeInitialize
  -> PoolManager 初始化池状态
  -> afterInitialize

modifyLiquidity（加/减流动性）
  -> beforeAddLiquidity / beforeRemoveLiquidity
  -> PoolManager 修改头寸
  -> afterAddLiquidity / afterRemoveLiquidity

swap
  -> beforeSwap
  -> PoolManager 执行 swap 核心逻辑
  -> afterSwap

donate
  -> beforeDonate
  -> PoolManager donate
  -> afterDonate
```

这些切点能干什么？

- before：做校验、改参数、收取 hook fee、拒绝某类交易、路由到自定义曲线等
- after：做统计、把一部分 delta 分配给 hook、奖励 LP、记录交易信息等

参考（官方概念页）：https://docs.uniswap.org/contracts/v4/concepts/hooks

---

## 四、最关键的“怪设定”：权限写在 Hook 地址的低位里

v4 判断某个 Hook 是否启用某个切点，不是看接口是否实现，也不是看注册表，而是：

> **检查 Hook 合约地址的最低若干位（least significant bits）**  
> 地址位中对应的 bit = 1，PoolManager 才会去调用该 Hook 函数。

这意味着：

- **权限在部署时就确定了，后续不可升级变更（至少不可通过“增加某个 hook 回调”来获得调用）**
- **即使你写了 `beforeSwap`，如果地址位没有打开 `BEFORE_SWAP_FLAG`，它永远不会被调用**
- **相反，如果地址位打开了某个 flag，但函数没有按期望返回值实现，交易可能直接 revert**

官方 Hooks 库里定义了完整的 flag 列表（包含“哪些 hook 会被调用”和“哪些 hook 允许返回 delta”）：

- BEFORE_INITIALIZE_FLAG = 1 << 13
- AFTER_INITIALIZE_FLAG = 1 << 12
- BEFORE_ADD_LIQUIDITY_FLAG = 1 << 11
- AFTER_ADD_LIQUIDITY_FLAG = 1 << 10
- BEFORE_REMOVE_LIQUIDITY_FLAG = 1 << 9
- AFTER_REMOVE_LIQUIDITY_FLAG = 1 << 8
- BEFORE_SWAP_FLAG = 1 << 7
- AFTER_SWAP_FLAG = 1 << 6
- BEFORE_DONATE_FLAG = 1 << 5
- AFTER_DONATE_FLAG = 1 << 4
- BEFORE_SWAP_RETURNS_DELTA_FLAG = 1 << 3
- AFTER_SWAP_RETURNS_DELTA_FLAG = 1 << 2
- AFTER_ADD_LIQUIDITY_RETURNS_DELTA_FLAG = 1 << 1
- AFTER_REMOVE_LIQUIDITY_RETURNS_DELTA_FLAG = 1 << 0

参考（官方 Hooks 库文档，含示例地址位解释）：https://docs.uniswap.org/contracts/v4/reference/core/libraries/Hooks

### 这对开发者意味着什么？

Hook 部署通常会用 `CREATE2`（或“挖地址”）来得到某个满足低位 flag 组合的地址；同时强烈建议继承官方 `BaseHook`，它会在部署时校验 `getHookPermissions()` 和地址位的一致性，避免“写了但不生效 / 生效但会崩”的情况。

---

## 五、IHooks 接口：函数都长什么样？

Hook 的外部接口由 `IHooks` 定义，PoolManager 只会通过这些入口调用你。

下面挑最常用的 swap 与流动性相关函数（完整列表见官方接口页）：

```solidity
function beforeSwap(
    address sender,
    PoolKey calldata key,
    IPoolManager.SwapParams calldata params,
    bytes calldata hookData
) external returns (bytes4, BeforeSwapDelta, uint24);

function afterSwap(
    address sender,
    PoolKey calldata key,
    IPoolManager.SwapParams calldata params,
    BalanceDelta delta,
    bytes calldata hookData
) external returns (bytes4, int128);

function beforeAddLiquidity(
    address sender,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata params,
    bytes calldata hookData
) external returns (bytes4);

function afterAddLiquidity(
    address sender,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata params,
    BalanceDelta delta,
    BalanceDelta feesAccrued,
    bytes calldata hookData
) external returns (bytes4, BalanceDelta);
```

参考（官方 IHooks 接口页）：https://docs.uniswap.org/contracts/v4/reference/core/interfaces/IHooks

### 参数怎么理解？（对读者最重要的部分）

- `sender`：最初调用 PoolManager 的 `msg.sender`，通常是 Router/PositionManager，不一定是最终用户
- `key`：池子的唯一配置（token0/token1/fee/tickSpacing/hookAddress 等）
- `params`：本次操作参数（swap 或 modifyLiquidity）
- `hookData`：调用方透传给 Hook 的 bytes，通常用来传入“最终用户是谁/本次操作的额外配置/签名等”
- `BalanceDelta / BeforeSwapDelta`：v4 的核心记账模型是“delta 记账”（一次交易结束再统一结算），Hook 也能参与这个 delta 的分配

---

## 六、示例 1：最小可用 Hook（统计某个池的 swap 次数）

这个例子只做一件事：每次 swap 时给计数器 +1。它能让读者快速建立三件事的直觉：

- Hook 合约可以服务多个池：状态要用 `poolId` 分桶
- Hook 的回调一般写在 `_beforeSwap/_afterSwap` 这种内部函数里（外部入口由基类处理）
- 返回值必须按协议要求返回对应 selector

```solidity
pragma solidity ^0.8.26;

import {BaseHook} from "v4-periphery/src/utils/BaseHook.sol";
import {Hooks} from "v4-core/src/libraries/Hooks.sol";
import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
import {PoolKey} from "v4-core/src/types/PoolKey.sol";
import {PoolId, PoolIdLibrary} from "v4-core/src/types/PoolId.sol";
import {BalanceDelta} from "v4-core/src/types/BalanceDelta.sol";
import {BeforeSwapDelta, BeforeSwapDeltaLibrary} from "v4-core/src/types/BeforeSwapDelta.sol";

contract SwapCounterHook is BaseHook {
    using PoolIdLibrary for PoolKey;

    mapping(PoolId => uint256) public beforeSwapCount;
    mapping(PoolId => uint256) public afterSwapCount;

    constructor(IPoolManager poolManager) BaseHook(poolManager) {}

    function getHookPermissions() public pure override returns (Hooks.Permissions memory) {
        return Hooks.Permissions({
            beforeInitialize: false,
            afterInitialize: false,
            beforeAddLiquidity: false,
            afterAddLiquidity: false,
            beforeRemoveLiquidity: false,
            afterRemoveLiquidity: false,
            beforeSwap: true,
            afterSwap: true,
            beforeDonate: false,
            afterDonate: false,
            beforeSwapReturnDelta: false,
            afterSwapReturnDelta: false,
            afterAddLiquidityReturnDelta: false,
            afterRemoveLiquidityReturnDelta: false
        });
    }

    function _beforeSwap(
        address,
        PoolKey calldata key,
        IPoolManager.SwapParams calldata,
        bytes calldata
    ) internal override returns (bytes4, BeforeSwapDelta, uint24) {
        beforeSwapCount[key.toId()] += 1;
        return (BaseHook.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);
    }

    function _afterSwap(
        address,
        PoolKey calldata key,
        IPoolManager.SwapParams calldata,
        BalanceDelta,
        bytes calldata
    ) internal override returns (bytes4, int128) {
        afterSwapCount[key.toId()] += 1;
        return (BaseHook.afterSwap.selector, 0);
    }
}
```

参考（官方 Swap Hook Quickstart，含完整示例）：https://docs.uniswap.org/contracts/v4/quickstart/hooks/swap

---

## 七、示例 2：白名单池（只允许特定用户 swap）

这个例子很常见：机构池、Launchpad 池、或只想让某类地址交易。关键点在于：`sender` 通常是 Router，因此 Hook 常用做法是**让 Router 把“最终用户地址”塞进 `hookData`**，Hook 再去校验。

下面只展示核心思路（重点是 `hookData` 的解码与校验）：

```solidity
pragma solidity ^0.8.26;

import {BaseHook} from "v4-periphery/src/utils/BaseHook.sol";
import {Hooks} from "v4-core/src/libraries/Hooks.sol";
import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
import {PoolKey} from "v4-core/src/types/PoolKey.sol";
import {BalanceDelta} from "v4-core/src/types/BalanceDelta.sol";
import {BeforeSwapDelta, BeforeSwapDeltaLibrary} from "v4-core/src/types/BeforeSwapDelta.sol";

contract WhitelistSwapHook is BaseHook {
    mapping(address => bool) public allowed;
    address public owner;

    constructor(IPoolManager poolManager) BaseHook(poolManager) {
        owner = msg.sender;
    }

    function setAllowed(address user, bool ok) external {
        require(msg.sender == owner);
        allowed[user] = ok;
    }

    function getHookPermissions() public pure override returns (Hooks.Permissions memory) {
        return Hooks.Permissions({
            beforeInitialize: false,
            afterInitialize: false,
            beforeAddLiquidity: false,
            afterAddLiquidity: false,
            beforeRemoveLiquidity: false,
            afterRemoveLiquidity: false,
            beforeSwap: true,
            afterSwap: false,
            beforeDonate: false,
            afterDonate: false,
            beforeSwapReturnDelta: false,
            afterSwapReturnDelta: false,
            afterAddLiquidityReturnDelta: false,
            afterRemoveLiquidityReturnDelta: false
        });
    }

    function _beforeSwap(
        address,
        PoolKey calldata,
        IPoolManager.SwapParams calldata,
        bytes calldata hookData
    ) internal view override returns (bytes4, BeforeSwapDelta, uint24) {
        address user = abi.decode(hookData, (address));
        require(allowed[user]);
        return (BaseHook.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);
    }
}
```

读者落地时要注意两点：

- Router 必须负责把最终用户写入 `hookData`（否则 Hook 只能看到 Router 地址）
- 白名单是强约束：如果 Hook revert，该池所有 swap 直接失败（这是“池行为的一部分”，不是外围约束）

---

## 八、示例 3：Hook Fee（在 beforeSwap 里额外收一笔费用）

这是 Hooks 最“有生产价值”的能力之一：你可以把某类收益直接做进池行为里，而不用用户单独执行额外交易。

v4 之所以能做到这一点，靠的是 **delta 记账 + BeforeSwapDelta**：

- Hook 在 `beforeSwap` 返回一个 `BeforeSwapDelta`
- PoolManager 会把这个 delta 纳入本次交易的净额结算
- 交易结束统一结算，Hook 也能“在同一笔 swap 里收钱”

官方对 `BeforeSwapDelta` 的解释与用法见这里（包含它如何“把欠款从 hook 转移给 router”）：https://docs.uniswap.org/contracts/v4/reference/core/types/beforeswapdelta-guide

下面给一个“按输入额外抽成”的骨架（只覆盖 `amountSpecified > 0` 的 exact input 场景；读者可以自行扩展到 exact output）：

```solidity
pragma solidity ^0.8.26;

import {BaseHook} from "v4-periphery/src/utils/BaseHook.sol";
import {Hooks} from "v4-core/src/libraries/Hooks.sol";
import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";
import {PoolKey} from "v4-core/src/types/PoolKey.sol";
import {BeforeSwapDelta, BeforeSwapDeltaLibrary} from "v4-core/src/types/BeforeSwapDelta.sol";

contract FeeHook is BaseHook {
    uint256 public constant HOOK_FEE_BPS = 10;

    constructor(IPoolManager poolManager) BaseHook(poolManager) {}

    function getHookPermissions() public pure override returns (Hooks.Permissions memory) {
        return Hooks.Permissions({
            beforeInitialize: false,
            afterInitialize: false,
            beforeAddLiquidity: false,
            afterAddLiquidity: false,
            beforeRemoveLiquidity: false,
            afterRemoveLiquidity: false,
            beforeSwap: true,
            afterSwap: false,
            beforeDonate: false,
            afterDonate: false,
            beforeSwapReturnDelta: true,
            afterSwapReturnDelta: false,
            afterAddLiquidityReturnDelta: false,
            afterRemoveLiquidityReturnDelta: false
        });
    }

    function _beforeSwap(
        address,
        PoolKey calldata,
        IPoolManager.SwapParams calldata params,
        bytes calldata
    ) internal pure override returns (bytes4, BeforeSwapDelta, uint24) {
        require(params.amountSpecified > 0);

        uint256 amountIn = uint256(int256(params.amountSpecified));
        uint256 fee = (amountIn * HOOK_FEE_BPS) / 10_000;

        BeforeSwapDelta delta = BeforeSwapDeltaLibrary.toBeforeSwapDelta(int128(int256(fee)), 0);
        return (BaseHook.beforeSwap.selector, delta, 0);
    }
}
```

如果你想把这个例子写到“可跑通”，推荐直接对照官方的 custom accounting guide，它把 fee 如何影响最终结算讲得很细（并给了完整合约）：https://docs.uniswap.org/contracts/v4/guides/custom-accounting

---

## 九、设计 Hook 时的几个“坑”（读者最容易踩）

### 1) 不要把 `sender` 当成最终用户

`sender` 通常是 Router/PositionManager。你要识别最终用户，通常通过：

- Router 把用户地址编码进 `hookData`
- 或者 Hook 自己提供一个入口，让用户先在 Hook 里登记，再由 Hook 代表用户调用 PoolManager

### 2) 权限位不对，功能要么不生效，要么直接炸

Hook 是否会被调用、以及是否允许返回 delta，取决于地址低位 flag。部署后改不了。

### 3) Hook 既是“功能”，也是“共识”

一旦某个池绑定了 Hook，用户就默认接受：

- swap 会被额外校验/额外收费/额外分配
- 甚至可能被某种规则拒绝（白名单、KYC、时间窗、价格带等）

因此写 Hook 时要把它当成“协议的一部分”来做审计与边界处理。

### 4) 尽量少做外部调用，避免把池变成 DoS 入口

Hook 是交易路径上的同步逻辑：如果你在 Hook 里依赖外部协议调用、依赖复杂循环、或引入可被操纵的预言机，都会把池变成高风险组件。

---

## 十、一句话总结 + 推荐学习路径

一句话总结：

**Hooks = 把“池的行为”开放成可编程接口，而不是在 Router 层做外围约束。**

建议学习路径（从易到难）：

- 先写计数器类 Hook（理解生命周期、`poolId` 分桶、权限位）
- 再写白名单/限价单类 Hook（理解 `hookData` 与用户身份）
- 最后写 hook fee / 自定义曲线（理解 delta 记账与 return delta）

---

## 参考链接

1. Hooks 概念：https://docs.uniswap.org/contracts/v4/concepts/hooks
2. IHooks 接口：https://docs.uniswap.org/contracts/v4/reference/core/interfaces/IHooks
3. Hooks flags 与地址位：https://docs.uniswap.org/contracts/v4/reference/core/libraries/Hooks
4. Swap Hook Quickstart：https://docs.uniswap.org/contracts/v4/quickstart/hooks/swap
5. BeforeSwapDelta 指南：https://docs.uniswap.org/contracts/v4/reference/core/types/beforeswapdelta-guide
6. Custom Accounting 指南：https://docs.uniswap.org/contracts/v4/guides/custom-accounting
